library(expm)
# Constructor for continuous phase-type distribution
contphasetype <- function(initDist, T.mat){
if((sum(initDist) > 1) | (sum(initDist < 0) > 0)) stop("Not a valid initial distribution")
if(det(T.mat)==0) stop("Not a valid subintensity matrix")
if(length(initDist) != nrow(T.mat)) stop("The dimensions of the input should be the same")
tmp <- list("initDist" = initDist, "T.mat" = T.mat)
class(tmp) <- "contphasetype"
tmp
}
# Constructor for discrete phase-type distribution
discphasetype <- function(initDist, T.mat){
T.mat <- as.matrix(T.mat)
if((sum(initDist) > 1) | (sum(initDist < 0) > 0)) stop("Not a valid initial distribution")
if((det(T.mat) == 0) | (sum(T.mat < 0) == 0) | (sum(rowSums(T.mat) > 1) > 0)) {
stop("Not a valid subtransition matrix")
}
if(length(initDist) != nrow(T.mat)) stop("The dimensions of the input should be the same")
tmp <- list("initDist" = initDist, "T.mat" = T.mat)
class(tmp) <- "discphasetype"
tmp
}
# Summary for continuous phase-type distribution
summary.contphasetype <- function(x){
cat("A continuous phase-type distribution with initial probability vector \n")
print(x$initDist)
cat("and subintensity matrix \n")
print(x$T.mat)
if(sum(x$initDist) < 1){
cat("and defect\n", 1-sum(x$initDist))
}
}
# Summary for discrete phase-type distribution
summary.discphasetype <- function(x){
cat("A discrete phase-type distribution with initial probability vector \n")
print(x$initDist)
cat("and subtransition matrix \n")
print(x$T.mat)
if(sum(x$initDist) < 1){
cat("and defect\n", 1-sum(x$initDist))
}
}
## Purpose: Computing the denisty function of a continuous
##          phase-type distribution
##          (using Theorem 1.2.58 in [BN])
## Input:
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## The density function at x, f_tau(x)
##----------------------------------------------------
ddiscphasetype <- function(x, initDist, T.mat){
sum(initDist%*%(T.mat %^% x)%*%(diag(1, nrow = nrow(T.mat))-T.mat))
}
## Name: dphasetype.discphasetype
## Purpose: Computing the density function of a continuous
##          phase-type distribution
##          (using Theorem 1.2.58 in [BN])
## Input:
## dptd = the discrete phase-type distribution object
##
## Output:
## The density function at x, f_tau(x)
##----------------------------------------------------
dphasetype.discphasetype <- function(dptd,x){
ddiscphasetype(x = x, initDist = dptd$initDist, T.mat = dptd$T.mat)
}
solve(matrix(2,0,-1,2))
solve(matrix(c(2,0,-1,2), ncol = 2))
ksjd <- discphasetype(c(.4,.4),matrix(c(.5,0,.25,.5), ncol = 2))
kjsdasd <- solve(matrix(c(2,0,-1,2), ncol = 2))
sum(kjsdasd < 0)
# Constructor for discrete phase-type distribution
discphasetype <- function(initDist, T.mat){
T.mat <- as.matrix(T.mat)
if((sum(initDist) > 1) | (sum(initDist < 0) > 0)) stop("Not a valid initial distribution")
if((det(T.mat) == 0) | (sum(T.mat < 0) != 0) | (sum(rowSums(T.mat) > 1) > 0)) {
stop("Not a valid subtransition matrix")
}
if(length(initDist) != nrow(T.mat)) stop("The dimensions of the input should be the same")
tmp <- list("initDist" = initDist, "T.mat" = T.mat)
class(tmp) <- "discphasetype"
tmp
}
sum(kjsdasd < 0)
ksjd <- discphasetype(c(.4,.4),matrix(c(.5,0,.25,.5), ncol = 2))
dphasetype(ksjd, 4)
dphasetype <- function(...){
UseMethod("dphasetype")
}
## Name: dphasetype.discphasetype
## Purpose: Computing the density function of a continuous
##          phase-type distribution
##          (using Theorem 1.2.58 in [BN])
## Input:
## dptd = the discrete phase-type distribution object
##
## Output:
## The density function at x, f_tau(x)
##----------------------------------------------------
dphasetype.discphasetype <- function(dptd,x){
ddiscphasetype(x = x, initDist = dptd$initDist, T.mat = dptd$T.mat)
}
ksjd <- discphasetype(c(.4,.4),matrix(c(.5,0,.25,.5), ncol = 2))
dphasetype(ksjd, 4)
##          phase-type distribution
##          (using Theorem 1.2.59 in [BN])
## Input:
## x = the number at which the distribution is evaluated
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## The distribution function at x, F_tau(x)
##----------------------------------------------------
pdiscphasetype <- function(x, initDist, T.mat){
return(1 - sum(initDist%*%(T.mat %^% x)))
}
# The generic function
pphasetype <- function(...){
UseMethod("pphasetype")
}
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## p = the probability at which the quantile function is evaluated
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## The quantile function at p
##----------------------------------------------------
qcontphasetype <- function(p, initDist, T.mat){
uniroot(function(y) pphasetype(x = y, initDist = initDist, T.mat = T.mat)-p, c(0, 400))$root[1]
}
qphasetype <- function(...){
UseMethod("qphasetype")
}
## Purpose: Computing the quantile function of a continuous
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## cptd = The continuous phase-type distribution object
## p = the probability at which the quantile function is evaluated
##
## Output:
## The quantile function at p
##----------------------------------------------------
qphasetype.contphasetype <- function(cptd, p){
qcontphasetype(p = p, initDist = cptd$initDist, T.mat = cptd$T.mat)
}
ksd <- contphasetype(initDist = c(.5,.5), T.mat = matrix(c(-1,0,1,-1), ncol = 2))
qphasetype(ksd, .5)
##          phase-type distribution
##          (using Theorem 3.1.8 in [BN])
## Input:
## x = the number at which the distribution is evaluated
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## The distribution function at x, F_tau(x)
##----------------------------------------------------
pcontphasetype <- function(x, initDist, T.mat){
return(1 - sum(initDist %*% expm(x * T.mat)))
}
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## p = the probability at which the quantile function is evaluated
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## The quantile function at p
##----------------------------------------------------
qcontphasetype <- function(p, initDist, T.mat){
uniroot(function(y) pcontphasetype(x = y, initDist = initDist, T.mat = T.mat)-p, c(0, 400))$root[1]
}
qphasetype <- function(...){
UseMethod("qphasetype")
}
## Purpose: Computing the quantile function of a continuous
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## cptd = The continuous phase-type distribution object
## p = the probability at which the quantile function is evaluated
##
## Output:
## The quantile function at p
##----------------------------------------------------
qphasetype.contphasetype <- function(cptd, p){
qcontphasetype(p = p, initDist = cptd$initDist, T.mat = cptd$T.mat)
}
qphasetype(ksd, .5)
qphasetype(ksd, .3)
qphasetype(ksd, .2)
qphasetype(ksd, .01)
qphasetype(ksd, .9)
?'<'
sample(4, prob = c(.1,.1,.1,.2))
sample(1:4, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
?sample
kjsdasd
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, -rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = Transmat[x,] )
}
}
}
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, -rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = TransMat[x,] )
}
}
}
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, 1-rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = TransMat[x,] )
}
}
}
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, 1-rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = TransMat[x,] )
}
}
}
return(tau)
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
rdiscphasetype(9, initDist = c(1,0), T.mat = kjsdasd)
ksd
ksjd
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## A vector of length n with outcomes from the continuous
## phase-type distribution
##----------------------------------------------------
rcontphasetype <- function(n, initDist, T.mat){
# Calculate the number of transient states
p <- length(initDist)
# Calculate the defect
defect <- 1 - sum(initDist)
# Initialize the vector with 0's because if the Markov Chain is absorbed immediately
# then tau would be 0
tau <- rep(0,n)
# If the defect is positive immediate absorption needs to be a possibility
# for that we generate n uniform(0,1) variables
if(defect < 1){
u <- runif(n)
}
# We make the rows of the intensity matrix corresponding to the transient states from
# the subintensity matrix
TransMat <- cbind(T.mat, 1-rowSums(T.mat))
# Now we simulate the Markov Jump Process until absorption in 'p+1'
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + rexp(1, rate = -TransMat[x,x])
x <- sample(p + 1, size = 1, prob = TransMat[x,-x] )
}
}
}
return(tau)
}
ksd
rcontphasetype(5, c(1,0), ksd$T.mat)
1:5+1[-2]
1:(5+1)[-2]
1:(5+1)[-1]
1:(5+1)[4]
(1:(5+1))[4]
(1:(5+1))[-1]
(1:(5+1))[-2]
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## A vector of length n with outcomes from the continuous
## phase-type distribution
##----------------------------------------------------
rcontphasetype <- function(n, initDist, T.mat){
# Calculate the number of transient states
p <- length(initDist)
# Calculate the defect
defect <- 1 - sum(initDist)
# Initialize the vector with 0's because if the Markov Chain is absorbed immediately
# then tau would be 0
tau <- rep(0,n)
# If the defect is positive immediate absorption needs to be a possibility
# for that we generate n uniform(0,1) variables
if(defect < 1){
u <- runif(n)
}
# We make the rows of the intensity matrix corresponding to the transient states from
# the subintensity matrix
IntenseMat <- cbind(T.mat, 1-rowSums(T.mat))
# Now we simulate the Markov Jump Process until absorption in 'p+1'
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + rexp(1, rate = -IntenseMat[x,x])
x <- sample((1:(p+1))[-x], size = 1, prob = IntenseMat[x,-x] )
}
}
}
return(tau)
}
rcontphasetype(5, c(1,0), ksd$T.mat)
rcontphasetype(5, c(.2,.2), ksd$T.mat)
rcontphasetype(5, c(.8,.2), ksd$T.mat)
?<
?'<'
