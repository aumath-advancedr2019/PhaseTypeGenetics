dphasetype(ksjd, 4)
##          phase-type distribution
##          (using Theorem 1.2.59 in [BN])
## Input:
## x = the number at which the distribution is evaluated
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## The distribution function at x, F_tau(x)
##----------------------------------------------------
pdiscphasetype <- function(x, initDist, T.mat){
return(1 - sum(initDist%*%(T.mat %^% x)))
}
# The generic function
pphasetype <- function(...){
UseMethod("pphasetype")
}
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## p = the probability at which the quantile function is evaluated
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## The quantile function at p
##----------------------------------------------------
qcontphasetype <- function(p, initDist, T.mat){
uniroot(function(y) pphasetype(x = y, initDist = initDist, T.mat = T.mat)-p, c(0, 400))$root[1]
}
qphasetype <- function(...){
UseMethod("qphasetype")
}
## Purpose: Computing the quantile function of a continuous
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## cptd = The continuous phase-type distribution object
## p = the probability at which the quantile function is evaluated
##
## Output:
## The quantile function at p
##----------------------------------------------------
qphasetype.contphasetype <- function(cptd, p){
qcontphasetype(p = p, initDist = cptd$initDist, T.mat = cptd$T.mat)
}
ksd <- contphasetype(initDist = c(.5,.5), T.mat = matrix(c(-1,0,1,-1), ncol = 2))
qphasetype(ksd, .5)
##          phase-type distribution
##          (using Theorem 3.1.8 in [BN])
## Input:
## x = the number at which the distribution is evaluated
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## The distribution function at x, F_tau(x)
##----------------------------------------------------
pcontphasetype <- function(x, initDist, T.mat){
return(1 - sum(initDist %*% expm(x * T.mat)))
}
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## p = the probability at which the quantile function is evaluated
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## The quantile function at p
##----------------------------------------------------
qcontphasetype <- function(p, initDist, T.mat){
uniroot(function(y) pcontphasetype(x = y, initDist = initDist, T.mat = T.mat)-p, c(0, 400))$root[1]
}
qphasetype <- function(...){
UseMethod("qphasetype")
}
## Purpose: Computing the quantile function of a continuous
##          phase-type distribution by numeric inversion
##          of the distribution function
## Input:
## cptd = The continuous phase-type distribution object
## p = the probability at which the quantile function is evaluated
##
## Output:
## The quantile function at p
##----------------------------------------------------
qphasetype.contphasetype <- function(cptd, p){
qcontphasetype(p = p, initDist = cptd$initDist, T.mat = cptd$T.mat)
}
qphasetype(ksd, .5)
qphasetype(ksd, .3)
qphasetype(ksd, .2)
qphasetype(ksd, .01)
qphasetype(ksd, .9)
?'<'
sample(4, prob = c(.1,.1,.1,.2))
sample(1:4, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
sample(4,1, prob = c(.1,.1,.1,.2))
?sample
kjsdasd
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, -rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = Transmat[x,] )
}
}
}
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, -rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = TransMat[x,] )
}
}
}
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, 1-rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = TransMat[x,] )
}
}
}
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subtransition matrix
##
## Output:
## A vector of length n with outcomes from the discrete
## phase-type distribution
##----------------------------------------------------
rdiscphasetype <- function(n, initDist, T.mat){
p <- length(initDist)
defect <- 1 - sum(initDist)
tau <- rep(1,n)
if(defect < 1){
u <- runif(n)
}
TransMat <- cbind(T.mat, 1-rowSums(T.mat))
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + 1
x <- sample(p + 1, size = 1, prob = TransMat[x,] )
}
}
}
return(tau)
}
rdiscphasetype(5, initDist = c(1,0), T.mat = kjsdasd)
rdiscphasetype(9, initDist = c(1,0), T.mat = kjsdasd)
ksd
ksjd
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## A vector of length n with outcomes from the continuous
## phase-type distribution
##----------------------------------------------------
rcontphasetype <- function(n, initDist, T.mat){
# Calculate the number of transient states
p <- length(initDist)
# Calculate the defect
defect <- 1 - sum(initDist)
# Initialize the vector with 0's because if the Markov Chain is absorbed immediately
# then tau would be 0
tau <- rep(0,n)
# If the defect is positive immediate absorption needs to be a possibility
# for that we generate n uniform(0,1) variables
if(defect < 1){
u <- runif(n)
}
# We make the rows of the intensity matrix corresponding to the transient states from
# the subintensity matrix
TransMat <- cbind(T.mat, 1-rowSums(T.mat))
# Now we simulate the Markov Jump Process until absorption in 'p+1'
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + rexp(1, rate = -TransMat[x,x])
x <- sample(p + 1, size = 1, prob = TransMat[x,-x] )
}
}
}
return(tau)
}
ksd
rcontphasetype(5, c(1,0), ksd$T.mat)
1:5+1[-2]
1:(5+1)[-2]
1:(5+1)[-1]
1:(5+1)[4]
(1:(5+1))[4]
(1:(5+1))[-1]
(1:(5+1))[-2]
##
## Input:
## n = the number of outcomes
## initDist = the initial distribution
## T.mat = the subintensity matrix
##
## Output:
## A vector of length n with outcomes from the continuous
## phase-type distribution
##----------------------------------------------------
rcontphasetype <- function(n, initDist, T.mat){
# Calculate the number of transient states
p <- length(initDist)
# Calculate the defect
defect <- 1 - sum(initDist)
# Initialize the vector with 0's because if the Markov Chain is absorbed immediately
# then tau would be 0
tau <- rep(0,n)
# If the defect is positive immediate absorption needs to be a possibility
# for that we generate n uniform(0,1) variables
if(defect < 1){
u <- runif(n)
}
# We make the rows of the intensity matrix corresponding to the transient states from
# the subintensity matrix
IntenseMat <- cbind(T.mat, 1-rowSums(T.mat))
# Now we simulate the Markov Jump Process until absorption in 'p+1'
for(i in 1:n){
if(u[i] <= defect){
next()
}
else{
initState <- sample(p, size = 1, prob = initDist)
x <- initState
while(x != p + 1){
tau[i] <- tau[i] + rexp(1, rate = -IntenseMat[x,x])
x <- sample((1:(p+1))[-x], size = 1, prob = IntenseMat[x,-x] )
}
}
}
return(tau)
}
rcontphasetype(5, c(1,0), ksd$T.mat)
rcontphasetype(5, c(.2,.2), ksd$T.mat)
rcontphasetype(5, c(.8,.2), ksd$T.mat)
?<
?'<'
#' @rdname add
contphasetype <- function(initDist, T.mat){
T.mat <- as.matrix(T.mat)
if(sum(initDist) > 1) stop("Not a valid initial distribution, as sum(initDist) > 1")
if(sum(initDist < 0) > 0) stop("Not a valid initial distribution, as some entries are negative")
if(nrow(T.mat)!= ncol(T.mat)) stop("The subintensity matrix is not a square matrix")
if(sum(diag(T.mat)>=0) > 0) stop("All diagonal entries of the subintensity matrix must be negative")
if(det(T.mat)==0) stop("A singular matrix is not a valid subintensity matrix")
if(sum(rowSums(T.mat) > 0) > 0) stop("The sums of the rows must be non-positive")
if(length(initDist) != nrow(T.mat)) stop("The dimensions of the input should be the same")
tmp <- list("initDist" = initDist, "T.mat" = T.mat)
class(tmp) <- "contphasetype"
return(tmp)
}
discphasetype <- function(initDist, P.mat){
P.mat <- as.matrix(P.mat)
if(sum(initDist) > 1) stop("Not a valid initial distribution, as sum(initDist) > 1")
if(sum(initDist < 0) > 0) stop("Not a valid initial distribution, as some entries are negative")
if(nrow(P.mat)!= ncol(P.mat)) stop("The subtransition matrix is not a square matrix")
if(det(P.mat) == 0) stop("A singular matrix is not a valid subtransition matrix")
if(sum(P.mat < 0) > 0) stop("Not a valid subtransition matrix, as some entries are negative")
if(sum(rowSums(P.mat) > 1) > 0) stop("Not a valid subtransition matrix. All rows should sum to a number less than or equal to one")
if(length(initDist) != nrow(P.mat)) stop("The dimensions of the input should be the same")
tmp <- list("initDist" = initDist, "P.mat" = P.mat)
class(tmp) <- "discphasetype"
return(tmp)
}
##          independent discrete phase-type distributed
##          variables.(using Theorem 1.2.65 in [BN])
##
## Input:
## object1,object2 = the discphasetype objects
##
## Output:
## A discphasetype object with the distribution
## of the sum of the input objects
##----------------------------------------------------
sum.discphasetype <- function(object1,object2){
initDist1 = object1$initDist
P.mat1 = object1$P.mat
initDist2 = object2$initDist
P.mat2 = object2$P.mat
newInitDist <- c(initDist1,rep(0,length(initDist2)))
newP.mat <- rbind(
cbind(P.mat1,(1-rowSums(P.mat1))%*%t(initDist2)),
cbind(matrix(0, nrow = length(initDist2), ncol = length(initDist2)), P.mat2))
discphasetype(initDist = newInitDist, P.mat = newP.mat)
}
##          independent continuous phase-type distributed
##          variables.(using Theorem 3.1.26 in [BN])
##
## Input:
## object1,object2 = the contphasetype objects
##
## Output:
## A contphasetype object with the distribution
## of the sum of the input objects
##----------------------------------------------------
sum.contphasetype <- function(object1,object2){
initDist1 = object1$initDist
T.mat1 = object1$T.mat
initDist2 = object2$initDist
T.mat2 = object2$T.mat
newInitDist <- c(initDist1,rep(0,length(initDist2)))
newT.mat <- rbind(
cbind(T.mat1, rowSums(-T.mat1) %*% t(initDist2)),
cbind(matrix(0, nrow = length(initDist2), ncol = length(initDist2)), T.mat2))
contphasetype(initDist = newInitDist, T.mat = newT.mat)
}
sum(contphasetype(1,-1),contphasetype(1,-1))
sum.contphasetype(contphasetype(1,-1),contphasetype(1,-1))
## Purpose: Computing the discrete phase-type parameters
##          for certain summary statistics for standard
##          coalescent model, that arise by sprinkling
##          mutations on a tree given by a certain rate
## Input:
## object = a continuous phase-type distribution object
## mutrate = the mutation rate
## Output:
## A discrete phase-type distribution object
##----------------------------------------------------
discretization <- function(object, mutrate){
discphasetype(initDist = object$initDist,
P.mat = solve(diag(nrow = nrow(object$T.mat))-2/mutrate*object$T.mat))
}
discretization(sum.contphasetype(contphasetype(1,-1),contphasetype(1,-1)),2)
discretization(sum.contphasetype(contphasetype(1,-1),contphasetype(1,-9)),2)
discretization(sum.contphasetype(contphasetype(1,-.4),contphasetype(1,-9)),.2)
discretization(sum.contphasetype(contphasetype(1,-.4),contphasetype(1,-9)),9)
#' @rdname add
contphasetype <- function(initDist, T.mat){
T.mat <- as.matrix(T.mat)
if(sum(initDist) > 1) stop("Not a valid initial distribution, as sum(initDist) > 1")
if(sum(initDist < 0) > 0) stop("Not a valid initial distribution, as some entries are negative")
if(nrow(T.mat)!= ncol(T.mat)) stop("The subintensity matrix is not a square matrix")
if(sum(diag(T.mat)>=0) > 0) stop("All diagonal entries of the subintensity matrix must be negative")
if(det(T.mat)==0) stop("A singular matrix is not a valid subintensity matrix")
if(sum(rowSums(T.mat) > 0) > 0) stop("The sums of the rows must be non-positive")
if(length(initDist) != nrow(T.mat)) stop("The dimensions of the input should be the same")
tmp <- list("initDist" = initDist, "T.mat" = T.mat)
class(tmp) <- "contphasetype"
return(tmp)
}
## Purpose: An implementation of Theorem 3.1.33 in
##         [BN](2017). That is, the function computes
##         the reward-transformed distribution
## Input:
## object = a continuous phasetype distribution object
## rewards = the non-negative reward vector
## Output:
## A new contphasetype object with the reward transformed
## parameters.
##----------------------------------------------------
RewTransDistribution <- function(object, rewards){
if(sum(rewards < 0) >0){
stop("The reward vector has to be non-negative!")
}else{
#We extract the initial distribution and subintensity matrix from the object
initDist <- object$initDist
T.mat <- object$T.mat
## We define the sets S^+ and S^0
S.plus <- which(rewards>0)
S.zero <- which(rewards==0)
## as well as the matrix Q
Q.mat <- -T.mat/diag(T.mat)
diag(Q.mat) <- 0
## We rearrange the states according to the
## sets S^+ and S^0:
Q.matpp <- Q.mat[S.plus,S.plus]
Q.matp0 <- Q.mat[S.plus,S.zero]
Q.mat0p <- Q.mat[S.zero,S.plus]
Q.mat00 <- Q.mat[S.zero,S.zero]
## Now we can define the transition matrix
## for the new markov chain
if(length(S.zero)==1){
P.mat <- Q.matpp+(1-Q.mat00)^(-1)*Q.matp0%*%t(Q.mat0p)
}else if(length(S.zero)==0){
P.mat <- Q.matpp
}else{
P.mat <- Q.matpp+Q.matp0%*%solve(diag(1,nrow = nrow(Q.mat00))-
Q.mat00)%*%Q.mat0p
}
## We define the new exit vector
p.vec <- 1-rowSums(P.mat)
## We also split the original initial distribution
## into pi = (pi^+,pi^0)
pi.vecp <- initDist[S.plus]
pi.vec0 <- initDist[S.zero]
## Then, the initial distribution of the new
## Markov chain is given by
if(length(S.zero)==1){
newInitDist <- pi.vecp + (1-Q.mat00)*pi.vec0%*%t(Q.mat0p)
}else if(length(S.zero)==0){
newInitDist <- pi.vecp
}else{
newInitDist <- pi.vecp + pi.vec0%*%solve(diag(1,nrow = nrow(Q.mat00))
-Q.mat00)%*%Q.mat0p
}
## Now we can define the subintensity matrix
## newT.mat as
if(length(S.plus)==1){
newT.mat <- -T.mat[S.plus,S.plus]/rewards[S.plus]*P.mat
exitrate <- -T.mat[S.plus,S.plus]/rewards[S.plus]*p.vec
}else{
newT.mat <- -diag(T.mat[S.plus,S.plus])/rewards[S.plus]*P.mat
exitrate <- -diag(T.mat[S.plus,S.plus])/rewards[S.plus]*p.vec
}
diag(newT.mat) <- -rowSums(newT.mat)-exitrate
}
return(contphasetype(initDist = newInitDist, T.mat = newT.mat))
}
RewTransDistribution(contphasetype(1,-1),0)
