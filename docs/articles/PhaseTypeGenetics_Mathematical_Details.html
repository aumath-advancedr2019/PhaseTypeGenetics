<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PhaseTypeGenetics - With mathematical details • PhaseTypeGenetics</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/sandstone/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="PhaseTypeGenetics - With mathematical details">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">PhaseTypeGenetics</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.5.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/PhaseTypeGenetics.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/PhaseTypeGenetics.html">An overview</a>
    </li>
    <li>
      <a href="../articles/PhaseTypeGenetics_Mathematical_Details.html">Mathematical details</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    News
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Release notes</li>
    <li>
      <a href="../news/index.html">Version 0.5.1</a>
    </li>
    <li class="divider">
    <li>
      <a href="../news/index.html">Change log</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/aumath-advancedr2019/PhaseTypeGenetics">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>PhaseTypeGenetics - With mathematical details</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/aumath-advancedr2019/PhaseTypeGenetics/blob/master/vignettes/PhaseTypeGenetics_Mathematical_Details.Rmd"><code>vignettes/PhaseTypeGenetics_Mathematical_Details.Rmd</code></a></small>
      <div class="hidden name"><code>PhaseTypeGenetics_Mathematical_Details.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span>(PhaseTypeGenetics)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">#&gt;  Thank you for choosing the package 'PhaseTypeGenetics'. </span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#&gt; </span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#&gt; We appreciate your support!</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt; </span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#&gt; </span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#&gt; </span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#&gt; Report a bug or ask a question about PhaseTypeGenetics at </span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">#&gt; </span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">#&gt; https://github.com/aumath-advancedr2019/phastypdist/issues.</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">#&gt; </span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">#&gt; </span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">#&gt; </span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co">#&gt; Now let's get started!</span></span></code></pre></div>
<div id="introduction-to-phasetypegenetics" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction-to-phasetypegenetics" class="anchor"></a>Introduction to PhaseTypeGenetics</h2>
<p>The aim of this package is to provide the user with some comprehensive tools to analyse discrete and continuous phase-type distributions. As recent research confirms the applicability of phase-type theory in population genetics, most of the examples provided in the package are based on coalescent theory. In addition, the package provides some function that are intended for the use in population genetics only.<br></p>
<p>All functions and applications are based on the theory developed in</p>
<ul>
<li>[BN] Mogens Bladt and Bo Friis Nielsen (2017): . Probability Theory and Stochastic Modelling (Springer), Volume 81</li>
<li>and [HSB] Asger Hobolth, Arno Siri-Jégousse, Mogens Bladt (2019): . Theoretical Population Biology, 127, pp. 16-32.</li>
</ul>
</div>
<div id="defining-phase-type-distributions" class="section level2">
<h2 class="hasAnchor">
<a href="#defining-phase-type-distributions" class="anchor"></a>Defining phase-type distributions</h2>
<p>This package is based on discrete and continuous phase-type distributions. In order to introduce the user to this topic and establish the notation that will be used throughout this vignette, we will give a short definition on both types of phase-type distributions.</p>
<div id="the-discrete-phase-type-distribution" class="section level3">
<h3 class="hasAnchor">
<a href="#the-discrete-phase-type-distribution" class="anchor"></a>The discrete phase-type distribution</h3>
<p>Let <span class="math inline">\(\{X_t\}_{t \in \mathbb{N}}\)</span> be a Markov chain with state space equal to <span class="math inline">\(\{1,2,...,p,p+1\}\)</span>. The states <span class="math inline">\(1,2,...,p\)</span> are assumed to be transient, while the last state <span class="math inline">\(p+1\)</span> is absorbing. Then we can define the transition matrix <span class="math display">\[\begin{equation*}
P = \begin{pmatrix}
T &amp; t \\
\boldsymbol{0} &amp; 1
\end{pmatrix},
\end{equation*}\]</span> where <span class="math inline">\(T\)</span> is a <span class="math inline">\(p \times p\)</span> sub-transition matrix holding the probabilities for jumping between all transient states and <span class="math inline">\(t\)</span> is a <span class="math inline">\(p\)</span>-dimensional column vector holding the exit probabilities (the probabilities for absorption). As all rows in the transition matrix <span class="math inline">\(P\)</span> have to sum to one, we can compute <span class="math inline">\(t\)</span> from the sub-transition matrix <span class="math inline">\(T\)</span>, <span class="math display">\[\begin{equation*}
Te +t = e \quad \Rightarrow \quad t=e-Te = (I-T)e
\end{equation*}\]</span> where <span class="math inline">\(e = (1,...,1)^T\)</span> is a <span class="math inline">\(p\)</span>-dimensional vector of ones.<br>
Now we let <span class="math inline">\(\pi_i = \mathbb{P}(X_0 =i)\)</span> be the initial probability for the process to start in state <span class="math inline">\(i\)</span> and <span class="math inline">\(\pi = (\pi_1,...,\pi_p)\)</span> be the initial distribution. As we do not want the process to start in the absorbing state, we assume that <span class="math inline">\(\pi_1+\cdots +\pi_p=1\)</span>.<br>
Finally, we let <span class="math inline">\(\tau = \inf\{t \geq 1 \mid X_t = p+1\}\)</span> be the waiting time until absorption in the last state of the Markov chain <span class="math inline">\(\{X_t\}_{t \in \mathbb{N}}\)</span>. Then we say that <span class="math inline">\(\tau\)</span> is discrete phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-transition probability matrix <span class="math inline">\(T\)</span>, <span class="math display">\[\begin{equation*}
\tau \sim \text{DPH}_p (\pi,T).
\end{equation*}\]</span></p>
</div>
<div id="the-continuous-phase-type-distribution" class="section level3">
<h3 class="hasAnchor">
<a href="#the-continuous-phase-type-distribution" class="anchor"></a>The continuous phase-type distribution</h3>
<p>The continuous phase-type distribution is defined in a corresponding way.<br>
Let <span class="math inline">\(\{X_t\}_{t \geq 0}\)</span> be a Markov jump process with state space equal to <span class="math inline">\(\{1,2,...,p,p+1\}\)</span> (here, the time is continuous). As in the discrete case, the states <span class="math inline">\(1,2,...,p\)</span> are assumed to be transient, while the last state <span class="math inline">\(p+1\)</span> is absorbing. Then we can rewrite the intensity rate matrix to be of the form <span class="math display">\[\begin{equation*}
\Lambda = \begin{pmatrix}
T &amp; t \\
\boldsymbol{0} &amp; 0
\end{pmatrix},
\end{equation*}\]</span> where <span class="math inline">\(T\)</span> is a <span class="math inline">\(p \times p\)</span> sub-intensity matrix holding the rates for jumping between all transient states and <span class="math inline">\(t\)</span> is a <span class="math inline">\(p\)</span>-dimensional column vector holding the exit rates. As all rows in an intensity rate matrix have to sum to zero, we can compute <span class="math inline">\(t\)</span> from the sub-intensity matrix <span class="math inline">\(T\)</span>, <span class="math display">\[\begin{equation*}
Te +t = \boldsymbol{0} \quad \Rightarrow \quad t=-Te 
\end{equation*}\]</span> where <span class="math inline">\(e = (1,...,1)^T\)</span> is a <span class="math inline">\(p\)</span>-dimensional vector of ones.<br>
Now we define the initial distribution. Let <span class="math inline">\(\pi_i = \mathbb{P}(X_0 =i)\)</span> be the initial probability for the process to start in state <span class="math inline">\(i\)</span> and <span class="math inline">\(\pi = (\pi_1,...,\pi_p)\)</span> be the initial distribution. As we do not want the process to start in the absorbing state, we assume that <span class="math inline">\(\pi_1+\cdots +\pi_p=1\)</span>.<br>
As before, we let <span class="math inline">\(\tau = \inf\{t &gt; 0 \mid X_t = p+1\}\)</span> be the waiting time until absorption in the last state. Then we say that <span class="math inline">\(\tau\)</span> is phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-intensity rate matrix <span class="math inline">\(T\)</span>, <span class="math display">\[\begin{equation*}
\tau \sim \text{PH}_p (\pi,T).
\end{equation*}\]</span></p>
</div>
</div>
<div id="applications-in-population-genetics" class="section level2">
<h2 class="hasAnchor">
<a href="#applications-in-population-genetics" class="anchor"></a>Applications in Population Genetics</h2>
<div id="the-wright-fisher-model" class="section level3">
<h3 class="hasAnchor">
<a href="#the-wright-fisher-model" class="anchor"></a>The Wright-Fisher model</h3>
<p>We consider the Wright-Fisher model, i.e. generations are non-overlapping, the population size is fixed and each individual chose its parents uniformly at random. Let <span class="math inline">\(N\)</span> be the population size and <span class="math inline">\(n\)</span> the sample size. Furthermore, let <span class="math inline">\(R_n\)</span> be the number of generations until coalescent of any of the <span class="math inline">\(n\)</span> individuals. Then it holds that the time measured in number of generations <span class="math inline">\(T_n = \tfrac{R_n}{n}\)</span> is approximately exponentially distributed with a rate of <span class="math inline">\(\binom{n}{2}\)</span>, <span class="math display">\[\begin{equation*}
T_n \sim \text{ Exp}(\binom{n}{2}).
\end{equation*}\]</span> Due to this definition, the time to the most recent common ancestor is given as <span class="math display">\[\begin{equation*}
T_{\text{MRCA}} = T_2 + \cdots + T_n
\end{equation*}\]</span> and the total branch length can be defined in the following way <span class="math display">\[\begin{equation*}
T_{\text{Total}} = 2T_2 + \cdots + nT_n
\end{equation*}\]</span></p>
<div id="example-1" class="section level4">
<h4 class="hasAnchor">
<a href="#example-1" class="anchor"></a>Example 1:</h4>
<p>For <span class="math inline">\(n=4\)</span>, a possible tree could be<br><img src="Tree_n4.png" width="70%"></p>
</div>
</div>
<div id="the-phase-type-distribution" class="section level3">
<h3 class="hasAnchor">
<a href="#the-phase-type-distribution" class="anchor"></a>The phase-type distribution</h3>
<p>We can think of a tree as a continuous time Markov chain (CTMC) or a Markov jump process in the following way. We let State 1 correspond to <span class="math inline">\(T_n\)</span>, State 2 denote <span class="math inline">\(T_{n-1}\)</span>, etc. Then State <span class="math inline">\(n-1\)</span> corresponds to <span class="math inline">\(T_2\)</span> and State <span class="math inline">\(n\)</span> is the absorbing state, where all individuals have found the most recent common ancestor. In this scenario, <span class="math inline">\(T_{MRCA}\)</span> is the waiting time for the process to be absorbed in state <span class="math inline">\(n\)</span>, <span class="math display">\[\begin{equation*}
T_{\text{MRCA}} = \tau_{\text{MRCA}} = \inf\{t &gt; 0 \mid X_t = \text{ State } n\}.
\end{equation*}\]</span> Due to the fact that <span class="math inline">\(T_k \sim \text{ Exp}(\binom{k}{2})\)</span>, the corresponding rate matrix is defined as <span class="math display">\[\begin{equation*}
\Lambda = \begin{pmatrix}
- \binom{n}{2} &amp; \binom{n}{2} &amp; 0 &amp; 0 &amp;\cdots &amp; 0 \\
0 &amp; -\binom{n-1}{2} &amp; \binom{n-1}{2} &amp; 0  &amp; \cdots &amp; 0 \\
\vdots &amp; 0 &amp; \ddots &amp; \ddots &amp; 0 &amp; 0 \\
0 &amp; \cdots &amp; 0 &amp; -3 &amp; 3 &amp; 0 \\
0 &amp; \cdots &amp; 0 &amp; 0 &amp; -1 &amp; 1 \\
0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{pmatrix}
\end{equation*}\]</span> and as we are interested in the whole tree, the initial distribution is <span class="math display">\[\begin{equation*}
\pi = (1,0,…,0),
\end{equation*}\]</span> i.e. the process always starts in State 1.<br>
As all rows in a rate matrix have to sum to zero, and as we are interested in the time spend in the transient states, we can disregard the last state (the absorbing state). Instead, we consider the sub-intensity rate matrix T, which is the upper left sub-matrix of <span class="math inline">\(\Lambda\)</span> <span class="math display">\[\begin{equation*}
\Lambda = \begin{pmatrix}
T &amp; t \\
\mathbf{0} &amp; 0
\end{pmatrix}
\end{equation*}\]</span> By letting <span class="math inline">\(p\)</span> denote the number of transient states, we have that <span class="math inline">\(T\)</span> is a <span class="math inline">\(p \times p\)</span> matrix, <span class="math inline">\(t\)</span> is a <span class="math inline">\(p \times 1\)</span> exit rate vector and <span class="math inline">\(\mathbf{0}\)</span> is a <span class="math inline">\(1 \times p\)</span> vector of zeros. As already mentioned, all rows in the generator matrix <span class="math inline">\(\Lambda\)</span> have to sum to zero, hence the exit rate vector can be computed as <span class="math display">\[\begin{equation*}
t = -T\boldsymbol{e},
\end{equation*}\]</span> where <span class="math inline">\(\boldsymbol{e}\)</span> is a <span class="math inline">\(p \times 1\)</span> vector with one in each entry. By disregarding the absorbing state, we also have to reduce the dimension of the initial distribution <span class="math inline">\(\pi= (\pi_1,…,\pi_p)\)</span>. In this new set-up, <span class="math inline">\(\pi\)</span> is now a <span class="math inline">\(1 \times p\)</span> vector that has to sum to one.<br>
Now we have that the waiting time to absorption in state <span class="math inline">\(p+1\)</span>, <span class="math inline">\(\tau = \inf \{t &gt; 0 \mid X_t =p+1\}\)</span> is phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-intensity rate matrix <span class="math inline">\(T\)</span>, and we write <span class="math display">\[\begin{equation*}
\tau \sim \text{PH}_p (\pi, T).
\end{equation*}\]</span></p>
</div>
<div id="transformation-via-rewards" class="section level3">
<h3 class="hasAnchor">
<a href="#transformation-via-rewards" class="anchor"></a>Transformation via rewards</h3>
<p>We can also define the total branch length as a phase-type distributed waiting time. In this situation, the initial distribution is the same, but the sub-intensity rate matrix <span class="math inline">\(T\)</span> looks different. As <span class="math display">\[\begin{equation*}
T_k \sim \text{Exp}(\binom{k}{2}) = \text{Exp}(\tfrac{k(k-1)}{2}) 
\end{equation*}\]</span> and as the exponential distribution is closed under scaling by a positive factor, <span class="math display">\[\begin{equation*}
k T_k \sim  \text{Exp}(\tfrac{k(k-1)}{2k})=  \text{Exp}(\tfrac{(k-1)}{2}).
\end{equation*}\]</span> Hence, the sub-intensity rate matrix for the total branch length is <span class="math display">\[\begin{equation*}
T= \tfrac{1}{2} \begin{pmatrix}
- (n-1) &amp; (n-1) &amp; 0 &amp; 0 &amp;\cdots &amp; 0 \\
0 &amp; -(n-2) &amp; (n-2) &amp; 0  &amp; \cdots &amp; 0 \\
\vdots &amp; 0 &amp; \ddots &amp; \ddots &amp; 0 &amp; 0 \\
0 &amp; \cdots &amp; 0 &amp;  &amp; -2 &amp; 2 \\
0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; -1 
\end{pmatrix}.
\end{equation*}\]</span> This is due to a concept called transformation via rewards. In general, we have that if <span class="math inline">\(\tau \sim \text{PH}_p (\pi, T)\)</span> with <span class="math inline">\(\{X_t\}_{t\geq0}\)</span> being the underlying Markov jump process and if <span class="math inline">\(\mathbf{r}= (r(1),..., r(p))\)</span> is a vector of non-negative reward rates, then the total reward <span class="math inline">\(Y\)</span> earned up to time <span class="math inline">\(\tau\)</span> is given as <span class="math display">\[\begin{equation*}
Y = \int_{0}^{\tau} r(X_t) dt.
\end{equation*}\]</span> This implies that if <span class="math inline">\(r(i)\neq 0\)</span> and <span class="math inline">\(T_k\sim \text{Exp}(\tfrac{k(k-1)}{2})\)</span> is a holding time in state <span class="math inline">\(i\)</span>, then the reward earned during this holding time is simply <span class="math display">\[\begin{equation*}
Y_k = r(k) T_k\sim \text{Exp}(\tfrac{k(k-1)}{2r(k)}).
\end{equation*}\]</span> As <span class="math inline">\(\mathbf{r}= (n,n-1,..., 2)\)</span> in connection to the total branch length, we get that <span class="math display">\[\begin{equation*}
Y_k = k T_k\sim \text{Exp}(\tfrac{(k-1)}{2}),
\end{equation*}\]</span> which is exactly what we have seen above.<br>
If <span class="math inline">\(r(i) \neq 0\)</span> for all <span class="math inline">\(i\)</span> and <span class="math inline">\(\Delta (\mathbf{r})\)</span> denotes the diagonal matrix satisfying that <span class="math inline">\(\Delta(\mathbf{r})_{ii} = r(i)\)</span>, then we have that <span class="math display">\[\begin{equation*}
Y \sim \text{PH}_p(\pi, \Delta^{-1} (\mathbf{r}) T),
\end{equation*}\]</span> which implies that the sub-intensity rate matrix for the total branch length is given as stated above.<br></p>
<p>The transformation via positive rewards can be extended to the case where <span class="math inline">\(r(i)\)</span> is zero for some <span class="math inline">\(i\)</span>’s. In this case, we call it transformation via non-negative rewards. This is important in connection to the site frequency spectrum.</p>
<div id="example-2" class="section level4">
<h4 class="hasAnchor">
<a href="#example-2" class="anchor"></a>Example 2:</h4>
<p>As before, we consider <span class="math inline">\(n=4\)</span>. In this situation, the Markov jump process would behave similar to the process displayed in the following graph<br><img src="CTMC_n4.png" width="70%"></p>
<p>The sub-intensity rate matrix corresponding to the time to the most recent common ancestor <span class="math inline">\(T_{\text{MRCA}}\)</span> would be <span class="math display">\[\begin{equation*}
T_{\text{MRCA}}= \begin{pmatrix}
-6 &amp; 6 &amp; 0 \\
0 &amp; -3&amp; 3  \\
0 &amp; 0  &amp; -1\\
\end{pmatrix}
\end{equation*}\]</span> and the sub-intensity rate matrix corresponding to the total branch length <span class="math inline">\(T_{\text{Total}}\)</span> would be <span class="math display">\[\begin{equation*}
T_{\text{Total}}= \tfrac{1}{2} \begin{pmatrix}
-3 &amp; 3 &amp; 0 \\
0 &amp; -2&amp; 2 \\
0 &amp; 0  &amp; -1\\
\end{pmatrix}.
\end{equation*}\]</span></p>
</div>
</div>
<div id="the-total-branch-length" class="section level3">
<h3 class="hasAnchor">
<a href="#the-total-branch-length" class="anchor"></a>The total branch length</h3>
<p>As before, we let <span class="math inline">\(\{X_t\}_{t\geq0}\)</span> be the underlying Markov jump process and we consider the time to the most recent common ancestor <span class="math inline">\(T_{\text{MRCA}} = \tau_{\text{MRCA}} \sim \text{PH}_p (\pi, T)\)</span>. But in this section, we use the block counting process to obtain the distribution of the waiting time <span class="math inline">\(\tau_{\text{MRCA}}\)</span>.<br>
From the block counting process, we get a state space and a sub-intensity rate matrix. Each state of the state space is represented by a <span class="math inline">\(n-1\)</span> dimensional vector, such that the <span class="math inline">\(i\)</span>’th entry corresponds to the number of branches giving rise to <span class="math inline">\(i\)</span>’tons. That is, the first entry corresponds to the number of branches giving rise to singletons, the second entry corresponds to the number of double-tons, etc. Due to this set-up, the total length of all branches that have <span class="math inline">\(i\)</span> descendants in the sample can be obtained by the aid of the transformation via rewards, <span class="math display">\[\begin{equation*}
\tau_i = \int_{0}^{\tau_{\text{MRCA}}} r_i(X_t) dt,
\end{equation*}\]</span> where <span class="math inline">\(r_i(j)\)</span> is the number of <span class="math inline">\(i\)</span>’tons in the <span class="math inline">\(j\)</span>’th state for all <span class="math inline">\(i,j \in \{1,...,n-1\}\)</span>.<br>
Then, <span class="math inline">\(\tau_i\)</span> is again phase type distributed with a new initial distribution, <span class="math inline">\(\pi_i\)</span>, a new sub-intensity rate matrix, <span class="math inline">\(T_i\)</span>, and defect size <span class="math inline">\(\pi_{i,d+1}\)</span>, where <span class="math inline">\(d\)</span> is the number of positive rewards (and hence the new number of transient states).<br></p>
<p>This approach can also be used to obtain the distribution of the total branch length. As before, the total branch length can be obtained by the aid of the transformation via rewards, <span class="math display">\[\begin{equation*}
\tau = \int_{0}^{\tau_{\text{MRCA}}} r(X_t) dt,
\end{equation*}\]</span> where <span class="math inline">\(r(j)= r_1(j) + \cdots + r_{n-1}(j)\)</span> is the sum of all <span class="math inline">\(i\)</span>’tons in state <span class="math inline">\(j\)</span> for all <span class="math inline">\(i,j \in \{1,...,n-1\}\)</span>.<br></p>
<div id="example-3" class="section level4">
<h4 class="hasAnchor">
<a href="#example-3" class="anchor"></a>Example 3:</h4>
<p>We continue the example with <span class="math inline">\(n=4\)</span>. In this case, there are two possible trees. One of which is displayed above, the other is displayed in the following graph</p>
<p><img src="Tree2_n4.png" width="50%"></p>
<p>The corresponding block counting process is given by</p>
<p><img src="BCP.png" width="40%"></p>
<p>and the sub-intensity rate matrix for this process is <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
-6 &amp; 6 &amp; 0 &amp; 0 \\
0 &amp; -3 &amp; 2 &amp; 1 \\
0 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1 
\end{pmatrix}.
\end{equation*}\]</span> Hence, the waiting time to the most recent common ancestor <span class="math inline">\(T_{\text{MRCA}} = \tau_{\text{MRCA}}\)</span> is now phase-type distributed with a different sub-intensity rate matrix.<br>
If we are interested in the total length of all branches giving rise to singletons, we have to give different rewards to the four states of the block counting process. Remember that the first tree had the following structure:</p>
<p><img src="T1_n4.png" width="40%"></p>
<p>Hence, the total length of all branches giving rise to singletons would be <span class="math inline">\(T_1 = 4T_4 + 2T_3 + 1T_2\)</span>. For the other tree, the total length of branches having one descendant in the sample would be <span class="math inline">\(T_1 = 4T_4 + 2T_3 + 0T_2\)</span>. Hence, <span class="math inline">\(\mathbf{r}_1 = (4,2,1,0)\)</span>. By using the reward transformation, we get that the total length of branches giving rise to singletons is phase-type distributed with initial distribution <span class="math inline">\(\pi_1 = (1,0,0)\)</span> and sub-intensity rate matrix <span class="math display">\[\begin{equation*}
T_1 = \begin{pmatrix}
-1.5 &amp; 1.5 &amp; 0 \\
0 &amp; -1.5 &amp; 1  \\
0 &amp; 0 &amp; -1  \\
\end{pmatrix}.
\end{equation*}\]</span> As one of the rewards is zero, we have a defect size of <span class="math inline">\(\pi_{1,d+1}=0\)</span>, where <span class="math inline">\(d=3\)</span>.<br>
We can also compute the total length of all branches <span class="math inline">\(\tau\)</span>. For both the first and the second tree, the total branch length is given as <span class="math inline">\(T = 4T_4 + 3T_3 + 2T_2\)</span>.Hence, the reward vector has to be <span class="math inline">\(\mathbf{r} = (4,3,2,2)\)</span>. By using the reward transformation, we get that the total branch length is phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0,0)\)</span> and sub-intensity rate matrix <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
-1.5 &amp; 1.5 &amp; 0 &amp; 0\\
0 &amp; -1 &amp; 2/3 &amp; 1/3\\
0 &amp; 0 &amp; -0.5 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -0.5\\
\end{pmatrix}.
\end{equation*}\]</span> This time, none of the rewards is zero. Hence, there is no defect size and the dimension of the new phase-type distribution is equal to the dimension of the original phase-type distribution.<br></p>
</div>
</div>
<div id="the-site-frequencies" class="section level3">
<h3 class="hasAnchor">
<a href="#the-site-frequencies" class="anchor"></a>The site frequencies</h3>
<p>Now that we have found the distribution of the branch lengths, it is straight forward to compute the distribution of the site frequencies <span class="math inline">\(\xi_i\)</span> for all <span class="math inline">\(i=1,...,n-1\)</span> and the number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span>.<br>
As before, we let <span class="math inline">\(\tau_i\)</span> denote the total length of all branches that have <span class="math inline">\(i\)</span> descendants in the sample and <span class="math inline">\(\tau\)</span> be the total length of all branches. Then, <span class="math display">\[\begin{equation*}
\tau_i \sim \text{PH}(\pi_i, T_i) \quad \text{and} \quad \tau \sim \text{PH}(\pi, T).
\end{equation*}\]</span> Furthermore, we let <span class="math inline">\(\lambda = \tfrac{\theta}{2}\)</span> be the mutation rate at the locus. Then it holds that the number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> conditionally on the total branch length <span class="math inline">\(\tau\)</span> is poisson distributed with rate <span class="math inline">\(\tfrac{\theta}{2} \tau\)</span>, i.e. <span class="math display">\[\begin{equation*}
S_{\text{Total}} \mid \tau \sim \text{Pois}(\tfrac{\theta}{2} \tau).
\end{equation*}\]</span> Due to the law of total probability, it now holds that <span class="math display">\[\begin{align*}
P(S_{\text{Total}}=n) &amp;= \int_{-\infty}^{\infty} P(S_{\text{Total}}=n \mid \tau = x) \cdot f_{\tau}(x) \quad dx\\
&amp;= \int_{0}^{\infty} \frac{(\lambda x)^n}{n!} e^{-\lambda x} \cdot f_{\tau}(x) \quad dx\\
&amp;= \frac{\lambda^n}{n!} \int_{0}^{\infty} x^n e^{-\lambda x} \cdot f_{\tau}(x) \quad dx
\end{align*}\]</span> for <span class="math inline">\(n \geq 0\)</span> and <span class="math inline">\(x \geq 0\)</span>, where we have used that <span class="math display">\[\begin{equation*}
P(S_{\text{Total}}=n \mid \tau = x) = \frac{(\lambda x)^n}{n!} e^{-\lambda x}.
\end{equation*}\]</span> But the Laplace transform for <span class="math inline">\(\tau\)</span> is given as <span class="math display">\[\begin{equation*}
L_{\tau} (\lambda) = \mathbb{E}[e^{-\lambda \tau}] = \int_{0}^{\infty} e^{-\lambda x} \cdot f_{\tau}(x) \quad dx,
\end{equation*}\]</span> and as the differential of <span class="math inline">\(L_{\tau} (\lambda)\)</span> with respect to <span class="math inline">\(\lambda\)</span> is given by <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial \lambda ^n} L_{\tau} (\lambda) = \int_{0}^{\infty} (-1)^n x^n e^{-\lambda x} \cdot f_{\tau}(x) \quad dx,
\end{align*}\]</span> we have that <span class="math display">\[\begin{align*}
P(S_{\text{Total}}=n) &amp;= \frac{\lambda^n}{n!} \int_{0}^{\infty} x^n e^{-\lambda x} \cdot f_{\tau}(x) \quad dx\\
&amp;= \frac{\lambda^n}{n!} (-1)^n \frac{\partial^n}{\partial \lambda ^n} L_{\tau} (\lambda).
\end{align*}\]</span> On the other hand, <span class="math display">\[\begin{align*}
L_{\tau} (\lambda) &amp;= \mathbb{E}[e^{-\lambda \tau}] = \int_{0}^{\infty} e^{-\lambda x} \cdot f_{\tau}(x) \quad dx\\
&amp;= \int_{0}^{\infty} e^{-\lambda x} \cdot \pi e^{Tx}t \quad dx\\
&amp;= \pi \int_{0}^{\infty} e^{-\lambda x} e^{Tx}\quad dx \, t \\
&amp;= \pi \int_{0}^{\infty} e^{x(T -\lambda I)} \quad dx \, t \\
&amp;= \pi \lim_{r \rightarrow \infty} \big[ (T -\lambda I)^{-1}e^{x(T -\lambda I)} \big]_{x=0}^{x=r}\, t\\
&amp;= \pi \Big( \lim_{r \rightarrow \infty}  (T -\lambda I)^{-1}e^{r(T -\lambda I)}  -  (T -\lambda I)^{-1}e^{0 \cdot (T -\lambda I)}\Big) t\\
&amp;= \pi \Big( 0 -  (T -\lambda I)^{-1}\Big) t\\
&amp;= -  \pi(T -\lambda I)^{-1}t\\
&amp;= \pi(\lambda I - T)^{-1}t
\end{align*}\]</span> where we have used that <span class="math display">\[\begin{equation*}
f_{\tau}(x) = \pi e^{Tx}t,
\end{equation*}\]</span> where <span class="math inline">\(t=-Te\)</span> is the exit rate vector and that <span class="math display">\[\begin{equation*}
\lim_{r \rightarrow \infty}  (T -\lambda I)^{-1}e^{r(T -\lambda I)} = 0,
\end{equation*}\]</span> as the eigenvalues of <span class="math inline">\((T -\lambda I)\)</span> are negative.<br>
But this implies that <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial \lambda ^n} L_{\tau} (\lambda) &amp;=   \frac{\partial^n}{\partial \lambda ^n} \pi(\lambda I - T)^{-1}t\\
&amp;= (-1)^{n} n! \pi(\lambda I - T)^{-n-1}t.
\end{align*}\]</span> We can insert this expression in the formula for <span class="math inline">\(P(S_{\text{Total}}=n)\)</span> <span class="math display">\[\begin{align*}
P(S_{\text{Total}}=n) &amp;= \frac{\lambda^n}{n!} (-1)^n \frac{\partial^n}{\partial \lambda ^n} L_{\tau} (\lambda)\\
&amp;= \frac{\lambda^n}{n!} (-1)^n (-1)^{n} n! \pi(\lambda I - T)^{-n-1}t\\
&amp;= \lambda^n\pi(\lambda I - T)^{-n-1}t\\
&amp;= \lambda^n \pi \lambda^{-(n+1)} (I - \lambda^{-1}T)^{-n-1}t\\
&amp;= \lambda^{-1} \pi (I - \lambda^{-1}T)^{-n-1}t.
\end{align*}\]</span> We can rewrite this expression in the following way <span class="math display">\[\begin{align*}
P(S_{\text{Total}}=n) &amp;= \pi (I - \lambda^{-1}T)^{-n}  \lambda^{-1} (I - \lambda^{-1}T)^{-1}t\\
&amp;= \pi P^n  p,
\end{align*}\]</span> where <span class="math display">\[\begin{equation*}
P = (I - \lambda^{-1}T)^{-1}
\end{equation*}\]</span> and <span class="math display">\[\begin{equation*}
p = \lambda^{-1} P t.
\end{equation*}\]</span> Then we have that <span class="math display">\[\begin{align*}
p &amp;= \lambda^{-1} P t = \lambda^{-1} (I - \lambda^{-1}T)^{-1} t\\
&amp;= -\lambda^{-1} (I - \lambda^{-1}T)^{-1} Te\\
&amp;= \boldsymbol{e} - \boldsymbol{e} -\lambda^{-1} (I - \lambda^{-1}T)^{-1} T\boldsymbol{e}\\
&amp;= \boldsymbol{e} - ( I + \lambda^{-1} (I - \lambda^{-1}T)^{-1} T)\boldsymbol{e}\\
&amp;= \boldsymbol{e} - (I - \lambda^{-1}T)^{-1}\boldsymbol{e}\\
&amp;= \boldsymbol{e} - P\boldsymbol{e},
\end{align*}\]</span> where the second last identity is due to the Woodbury matrix identity which states that <span class="math display">\[\begin{align*}
(I - \lambda^{-1}T)^{-1} = I + \lambda^{-1} (I - \lambda^{-1}T)^{-1} T.
\end{align*}\]</span> Hence, <span class="math display">\[\begin{align*}
P(S_{\text{Total}}=n) =  \pi P^n  p,
\end{align*}\]</span> where <span class="math display">\[\begin{equation*}
P = (I - \lambda^{-1}T)^{-1} \quad \text{ and } \quad p=\boldsymbol{e}-P\boldsymbol{e}.
\end{equation*}\]</span> We recognize this density as the density of a discrete phase-type distribution with sub-transition probability matrix <span class="math inline">\(P\)</span> and exit probability vector <span class="math inline">\(p\)</span>. As the discrete phase-type distributions is only defined for natural numbers excluding zero, we have to consider <span class="math inline">\(S_{\text{Total}} +1\)</span>, i.e.  <span class="math display">\[\begin{equation*}
S_{\text{Total}} +1 \sim \text{ DPH}(\pi, P).
\end{equation*}\]</span></p>
<p>We can repeat the same computations for <span class="math inline">\(\xi_i\)</span> with <span class="math inline">\(\tau\)</span> replaced with <span class="math inline">\(\tau_i\)</span>, <span class="math inline">\(T\)</span> replaced with <span class="math inline">\(T_i\)</span> and <span class="math inline">\(\pi\)</span> replaced with <span class="math inline">\(\pi_i\)</span> for all <span class="math inline">\(i=1,...,n-1\)</span> to see that <span class="math display">\[\begin{equation*}
\xi_i +1 \sim \text{ DPH}(\pi_i, P_i),
\end{equation*}\]</span> where <span class="math display">\[\begin{equation*}
P_i = (I - \lambda^{-1}T_i)^{-1} \quad \text{ and } \quad p_i=\boldsymbol{e}-P_i \boldsymbol{e}.
\end{equation*}\]</span></p>
<div id="example-4" class="section level4">
<h4 class="hasAnchor">
<a href="#example-4" class="anchor"></a>Example 4:</h4>
<p>For <span class="math inline">\(n=4\)</span>, we have seen that the total length of branches giving rise to singletons is discrete phase-type distributed with initial distribution <span class="math inline">\(\pi_i = (1,0,0)\)</span>, sub-intensity rate matrix <span class="math display">\[\begin{equation*}
T_i = \begin{pmatrix}
-1.5 &amp; 1.5 &amp; 0 \\
0 &amp; -1.5 &amp; 1  \\
0 &amp; 0 &amp; -1  \\
\end{pmatrix}.
\end{equation*}\]</span> and defect size <span class="math inline">\(\pi_{i,d+1}=0\)</span>, where <span class="math inline">\(d=3\)</span>. From above we have that the number of singletons plus one is again phase-type distributed with initial distribution <span class="math inline">\(\pi_i = (1,0,0)\)</span> and sub-transition probability matrix <span class="math display">\[\begin{equation*}
P_i = (I -\tfrac{2}{\theta} T_i)^{-1} = \begin{pmatrix}
0.4 &amp; 0.24 &amp; 0.12 \\
0 &amp; 0.4 &amp; 0.2  \\
0 &amp; 0 &amp; 0.5  \\
\end{pmatrix},
\end{equation*}\]</span> for <span class="math inline">\(\theta = 2\)</span>. The defect size is still <span class="math inline">\(\pi_{i,d+1}=0\)</span>.<br>
We can also compute the distribution of the number of segregating sites <span class="math inline">\(S_{\text{Total}} +1\)</span>. From the previous example, we have that the total branch length <span class="math inline">\(\tau\)</span> is phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0,0)\)</span> and sub-intensity rate matrix <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
-1.5 &amp; 1.5 &amp; 0 &amp; 0\\
0 &amp; -1 &amp; 2/3 &amp; 1/3\\
0 &amp; 0 &amp; -0.5 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -0.5\\
\end{pmatrix}.
\end{equation*}\]</span> Hence, the number of segregating sites plus one is also discrete phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0,0)\)</span> and sub-transition probability matrix <span class="math display">\[\begin{equation*}
P = (I -\tfrac{2}{\theta} T)^{-1} = \begin{pmatrix}
0.4 &amp; 0.3 &amp; 4/30 &amp; 2/30 \\
0 &amp; 0.5 &amp; 2/9 &amp; 1/9 \\
0 &amp; 0 &amp; 2/3 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 2/3 \\
\end{pmatrix},
\end{equation*}\]</span> for <span class="math inline">\(\theta = 2\)</span>.</p>
</div>
</div>
</div>
<div id="the-functions" class="section level2">
<h2 class="hasAnchor">
<a href="#the-functions" class="anchor"></a>The functions</h2>
<hr>
<p><strong>BlockCountProcess</strong> </p>
<hr>
<div id="the-block-counting-process" class="section level3">
<h3 class="hasAnchor">
<a href="#the-block-counting-process" class="anchor"></a>The block counting process</h3>
<p>The function <code>BlockCountProcess</code> is the first example of a function that is intended for the use in population genetics. It computes the state space and the corresponding rate matrix for the block counting process for a given sample size <span class="math inline">\(n\)</span> in the standard coalescent model.<br>
For any given sample size <span class="math inline">\(n\geq 1\)</span> there is one or more possible coalescent trees. Each coalescent event in these trees correspond to a state of the block counting process, and each state is represented by a <span class="math inline">\(n-1\)</span> dimensional vector, say <span class="math inline">\(S_i\)</span> for <span class="math inline">\(i\in\{1,...,s\}\)</span>, where <span class="math inline">\(s\)</span> is the number of states in the state space. Each entry <span class="math inline">\(j\)</span> in the vector <span class="math inline">\(S_i\)</span> corresponds to the number of branches giving rise to <span class="math inline">\(j\)</span> descendants. Due to this definition, <span class="math inline">\(S_1\)</span> is always of the form <span class="math inline">\((n,0,...,0)\)</span> and <span class="math inline">\(S_2\)</span> is always given by the vector <span class="math inline">\((n-2,1,...,0)\)</span>. This is due to the fact that in the first state <span class="math inline">\(S_1\)</span>, no coalescent events have taken place and we still consider all <span class="math inline">\(n\)</span> individuals, i.e. <span class="math inline">\(n\)</span> descendants. In the second state <span class="math inline">\(S_2\)</span>, two of the individuals have coalesced. Hence, there are <span class="math inline">\(n-2\)</span> branches giving rise to <span class="math inline">\(n-2\)</span> descendants and one branch giving rise to <span class="math inline">\(2\)</span> descendants.<br><br>
Note that this function uses the package <code>partitions</code>. Make sure to install this package to be able to use the function.</p>
<div id="example-5" class="section level4">
<h4 class="hasAnchor">
<a href="#example-5" class="anchor"></a>Example 5</h4>
<p>We consider the block counting process for <span class="math inline">\(n=4\)</span>. In a previous section we have seen that there are two possible trees</p>
<p><img src="Tree_n4.png" width="40%"><img src="Tree2_n4.png" width="40%"></p>
<p>that the corresponding block counting process is given by</p>
<p><img src="BCP.png" width="40%"></p>
<p>and that the sub-intensity rate matrix for this process is <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
-6 &amp; 6 &amp; 0 &amp; 0 \\
0 &amp; -3 &amp; 2 &amp; 1 \\
0 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1 
\end{pmatrix}.
\end{equation*}\]</span> Hence, for <span class="math inline">\(n=4\)</span> the number of states <span class="math inline">\(s\)</span> in the state space is 4 (without the last state MRCA) and the state space matrix <span class="math inline">\(S=(S_1,...,S_s)^T\)</span> is given by <span class="math display">\[\begin{equation*}
S = \begin{pmatrix}
4 &amp; 0 &amp; 0 \\
2 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 \\
0 &amp; 2 &amp; 0\\
\end{pmatrix}.
\end{equation*}\]</span> Instead of doing all of these computations by hand, we can use the function <code>BlockCountProcess</code> to obtain the state space matrix <span class="math inline">\(S\)</span> and the corresponding rate matrix</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw"><a href="../reference/BlockCountProcess.html">BlockCountProcess</a></span>(<span class="dt">n=</span><span class="dv">4</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">#&gt; $Rate_Mat</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">#&gt; [1,]   -6    6    0    0</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">#&gt; [2,]    0   -3    2    1</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">#&gt; [3,]    0    0   -1    0</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">#&gt; [4,]    0    0    0   -1</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">#&gt; </span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">#&gt; $StateSpace_Mat</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">#&gt; [1,]    4    0    0</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">#&gt; [2,]    2    1    0</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="co">#&gt; [3,]    1    0    1</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">#&gt; [4,]    0    2    0</span></span></code></pre></div>
<hr>
<p><strong>discphasetype &amp; contphasetype</strong> </p>
<hr>
</div>
</div>
<div id="objects-of-type-discphasetype-and-contphasetype" class="section level3">
<h3 class="hasAnchor">
<a href="#objects-of-type-discphasetype-and-contphasetype" class="anchor"></a>Objects of type <code>discphasetype</code> and <code>contphasetype</code>
</h3>
<p>In order to be able to use the functions in this package, it is necessary to define objects of S3 class <code>discphasetype</code> and <code>contphasetype</code>. An object of class <code>discphasetype</code> represents a discrete phase-type distributed object with initial distribution <code>initDist</code> and sub-transition probability matrix <code>P_Mat</code>. An object of class <code>contphasetype</code> represents a continuous phase-type distributed object with initial distribution <code>initDist</code> and sub-intensity rate matrix <code>T_Mat</code>.</p>
<div id="example-6" class="section level4">
<h4 class="hasAnchor">
<a href="#example-6" class="anchor"></a>Example 6</h4>
<p>For <span class="math inline">\(n=4\)</span>, the time to the most recent common ancestor is phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0)\)</span> and sub-intensity rate matrix <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
-6 &amp; 6 &amp; 0\\
0 &amp; -3 &amp; 3\\
0 &amp; 0 &amp; -1
\end{pmatrix}.
\end{equation*}\]</span> An object of class <code>contphasetype</code> is then obtained in the following way.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>initDist &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>,</span>
<span id="cb3-4"><a href="#cb3-4"></a>                  <span class="dv">0</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">3</span>,</span>
<span id="cb3-5"><a href="#cb3-5"></a>                  <span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>obj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(initDist, T_Mat)</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw"><a href="https://rdrr.io/r/base/summary.html">summary</a></span>(obj)</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">#&gt; A continuous phase-type distribution with initial probability vector </span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">#&gt; [1] 1 0 0</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#&gt; and subintensity matrix </span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#&gt; [1,]   -6    6    0</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#&gt; [2,]    0   -3    3</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">#&gt; [3,]    0    0   -1</span></span></code></pre></div>
<p>For <span class="math inline">\(\theta =2\)</span>, the number of segregating sites plus one is discrete phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0,0)\)</span> and sub-transition probability matrix <span class="math display">\[\begin{equation*}
P = \begin{pmatrix}
0.4 &amp; 0.3 &amp; 4/30 &amp; 2/30\\
0 &amp; 0.5 &amp; 2/9 &amp; 1/9\\
0 &amp; 0 &amp; 2/3 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 2/3
\end{pmatrix}.
\end{equation*}\]</span> An object of class <code>discphasetype</code> is then obtained in the following way.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>initDist &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>P_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.4</span>, <span class="fl">0.3</span>, <span class="dv">4</span><span class="op">/</span><span class="dv">30</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">30</span>,</span>
<span id="cb4-4"><a href="#cb4-4"></a>                  <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">9</span>,</span>
<span id="cb4-5"><a href="#cb4-5"></a>                  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">0</span>,</span>
<span id="cb4-6"><a href="#cb4-6"></a>                  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>), <span class="dt">nrow =</span> <span class="dv">4</span>, <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>S_Total &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">discphasetype</a></span>(initDist, P_Mat)</span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="kw"><a href="https://rdrr.io/r/base/summary.html">summary</a></span>(S_Total)</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">#&gt; A discrete phase-type distribution with initial probability vector </span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">#&gt; [1] 1 0 0 0</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">#&gt; and subtransition matrix </span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">#&gt;      [,1] [,2]      [,3]       [,4]</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">#&gt; [1,]  0.4  0.3 0.1333333 0.06666667</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">#&gt; [2,]  0.0  0.5 0.2222222 0.11111111</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="co">#&gt; [3,]  0.0  0.0 0.6666667 0.00000000</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co">#&gt; [4,]  0.0  0.0 0.0000000 0.66666667</span></span></code></pre></div>
<hr>
<p><strong>discretization</strong> </p>
<hr>
</div>
</div>
<div id="discretization-of-continuous-phase-type-distributions" class="section level3">
<h3 class="hasAnchor">
<a href="#discretization-of-continuous-phase-type-distributions" class="anchor"></a>Discretization of continuous phase-type distributions</h3>
<p>In the <code>PhaseTypeGenetics</code> package we have implemented two ways of transforming a sub-intensity matrix into a sub-transition probability matrix. These we have implemented in the <code>dicretization</code> function.</p>
<div id="the-first-transformation" class="section level4">
<h4 class="hasAnchor">
<a href="#the-first-transformation" class="anchor"></a>The first transformation</h4>
<p>Let <span class="math inline">\(T\)</span> be a sub-intensity matrix, then for any <span class="math inline">\(a\)</span> greater than the maximum of the absolute value of the diagonal entries of <span class="math inline">\(T\)</span>, <span class="math display">\[\begin{equation*}
I+a^{-1}T
\end{equation*}\]</span> is a sub-transition probability matrix. The function is implemented so that <code>discretization</code> applied to a <code>contphasetype</code> object with initial distribution <span class="math inline">\(\alpha\)</span> and sub-intensity matrix <span class="math inline">\(T\)</span> and a given <span class="math inline">\(a\)</span> returns a <code>discphasetype</code>object with initial distribution <span class="math inline">\(\alpha\)</span> and sub-transition probability matrix <span class="math inline">\(I+a^{-1}T\)</span>.</p>
</div>
<div id="the-second-transformation" class="section level4">
<h4 class="hasAnchor">
<a href="#the-second-transformation" class="anchor"></a>The second transformation</h4>
<p>The basis of this transformation is found in [HSB]. Let <span class="math inline">\(X\sim PH(\alpha,T)\)</span>. Then for a <span class="math inline">\(\lambda&gt;0\)</span> and a random variable <span class="math inline">\(Y\)</span> satisfying that <span class="math display">\[\begin{equation*}Y|X\sim\text{Poisson}(\lambda X),
\end{equation*}\]</span> is can be shown that <span class="math display">\[\begin{equation*}Y+1\sim DPH(\alpha,(I-\lambda^{-1}T)^{-1}).
\end{equation*}\]</span> The function is implemented so that <code>discretization</code> applied to a <code>contphasetype</code> object with initial distribution <span class="math inline">\(\alpha\)</span> and sub-intensity matrix <span class="math inline">\(T\)</span> and a given <span class="math inline">\(\lambda\)</span> returns a <code>discphasetype</code>object with initial distribution <span class="math inline">\(\alpha\)</span> and sub-transition probability matrix <span class="math inline">\((I-\lambda^{-1}T)^{-1})\)</span>.</p>
</div>
<div id="using-the-function" class="section level4">
<h4 class="hasAnchor">
<a href="#using-the-function" class="anchor"></a>Using the function</h4>
<p>The function takes three parameters: <code>object</code>, <code>a</code> and <code>lambda</code>.<br><code>object</code> must be of the class <code>contphasetype</code> and <code>a</code> and <code>lambda</code> mus be numbers greater than 0. <code>a</code> and <code>lambda</code> are both <code>NULL</code> as default. You must give either an <code>a</code> parameter or a <code>lambda</code> parameter.<br>
If the given <code>a</code> is greater than the maximum of the absolute value of the diagonal entries of the sub-intensity matrix of <code>object</code>, <code><a href="../reference/discretization.html">discretization(object = object,a = a)</a></code> performs the first transformation of the object. If <code>lambda</code> is given then <code><a href="../reference/discretization.html">discretization(object = object,lambda = lambda)</a></code> performs the second transformation of the object.<br>
It is also possible to give both an <code>a</code> and a <code>lambda</code>. <code><a href="../reference/discretization.html">discretization(object = object, a = a,lambda = lambda)</a></code>, returns a list where the first entry is the first transformation of <code>object</code> with <code>a</code> and the second entry is the second transformation of <code>object</code> with <code>lambda</code>.</p>
</div>
<div id="example-7" class="section level4">
<h4 class="hasAnchor">
<a href="#example-7" class="anchor"></a>Example 7</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>x_<span class="dv">1</span> &lt;-<span class="st">  </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">5</span>,.<span class="dv">2</span>,.<span class="dv">3</span>,<span class="dv">0</span>),</span>
<span id="cb5-2"><a href="#cb5-2"></a>                                 <span class="dt">T_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">4</span>), <span class="dt">nrow =</span> <span class="dv">4</span>))</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw"><a href="../reference/discretization.html">discretization</a></span>(x_<span class="dv">1</span>, <span class="dt">a =</span> <span class="dv">12</span>, <span class="dt">lambda =</span> <span class="dv">2</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">#&gt; $a</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">#&gt; [1] 0.5 0.2 0.3 0.0</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">#&gt; </span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">#&gt;            [,1]      [,2]      [,3]      [,4]</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">#&gt; [1,] 0.50000000 0.1666667 0.1666667 0.0000000</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">#&gt; [2,] 0.08333333 0.3333333 0.2500000 0.2500000</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">#&gt; [3,] 0.08333333 0.0000000 0.5833333 0.1666667</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co">#&gt; [4,] 0.00000000 0.0000000 0.0000000 0.6666667</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">#&gt; </span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">#&gt; [1] "discphasetype"</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">#&gt; </span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="co">#&gt; $lambda</span></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="co">#&gt; [1] 0.5 0.2 0.3 0.0</span></span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="co">#&gt; </span></span>
<span id="cb5-23"><a href="#cb5-23"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="co">#&gt;            [,1]        [,2] [,3]       [,4]</span></span>
<span id="cb5-25"><a href="#cb5-25"></a><span class="co">#&gt; [1,] 0.26923077 0.053846154  0.1 0.06025641</span></span>
<span id="cb5-26"><a href="#cb5-26"></a><span class="co">#&gt; [2,] 0.03846154 0.207692308  0.1 0.13717949</span></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co">#&gt; [3,] 0.03846154 0.007692308  0.3 0.10384615</span></span>
<span id="cb5-28"><a href="#cb5-28"></a><span class="co">#&gt; [4,] 0.00000000 0.000000000  0.0 0.33333333</span></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="co">#&gt; </span></span>
<span id="cb5-30"><a href="#cb5-30"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="co">#&gt; [1] "discphasetype"</span></span></code></pre></div>
<hr>
<p><strong>dphasetype, pphasetype, qphasetype &amp; rphasetype</strong> </p>
<hr>
<p>This package includes some functions that compute the basic properties of phase-type distributions, i.e. the density, distribution and quantile function as well as simulations.</p>
</div>
</div>
<div id="the-density" class="section level3">
<h3 class="hasAnchor">
<a href="#the-density" class="anchor"></a>The density</h3>
<div id="in-the-discrete-case" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case" class="anchor"></a>- in the discrete case</h4>
<p>In the following, let <span class="math inline">\(\tau= \inf\{t\geq 1 \mid X_t = p+1\}\)</span> be discrete phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-transition probability matrix <span class="math inline">\(T\)</span>, <span class="math inline">\(\tau \sim DPH_{p}(\pi,T)\)</span>.<br>
Then the density for <span class="math inline">\(\tau\)</span> is given by <span class="math display">\[\begin{align*}
\mathbb{P}(\tau= n) &amp;= \sum_{i=1}^{p} \mathbb{P}(\tau=n \mid X_{n-1}=i)\mathbb{P}(X_{n-1}=i)\\
&amp;= \sum_{i=1}^{p} \mathbb{P}(\tau=n \mid X_{n-1}=i) \sum_{j=1}^{p} \mathbb{P}(X_{n-1}=i \mid X_0 =j ) \mathbb{P}(X_0=j)\\
&amp;= \sum_{i=1}^{p} \sum_{j=1}^{p} \mathbb{P}(\tau=n \mid X_{n-1}=i)  \mathbb{P}(X_{n-1}=i \mid X_0 =j ) \mathbb{P}(X_0=j)\\
\end{align*}\]</span> for <span class="math inline">\(n \geq 1\)</span>, where the first and second equality are due to the law of total probability. Now we observe that the probability <span class="math inline">\(\mathbb{P}(X_0=j)\)</span> for the Markov jump process <span class="math inline">\((X_t)_{t\geq 0}\)</span> to start in <span class="math inline">\(j\)</span> is equal to the <span class="math inline">\(j\)</span>’th entry of the initial distribution. Furthermore, the probability <span class="math inline">\(\mathbb{P}(\tau=n \mid X_{n-1}=i)\)</span> for the process to be absorbed at time <span class="math inline">\(n\)</span>, given that the process is in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(n-1\)</span> is given by the <span class="math inline">\(i\)</span>’th entry of the exit probability vector <span class="math inline">\(t = \boldsymbol{e} - T \boldsymbol{e}\)</span>. Finally, the probability <span class="math inline">\(\mathbb{P}(X_{n-1}=i \mid X_0 =j )\)</span> for the process to be in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(n-1\)</span> given that the process started in state <span class="math inline">\(j\)</span> (or equivalently the probability of going from state <span class="math inline">\(j\)</span> to state <span class="math inline">\(i\)</span> in time <span class="math inline">\(n-1\)</span>) is given by the <span class="math inline">\((j,i)\)</span>’th element of sub-transition probability matrix <span class="math inline">\(T^{n-1}\)</span>. Hence, we have that<br><span class="math display">\[\begin{align*}
\mathbb{P}(\tau= n) &amp;= \sum_{i=1}^{p} \sum_{j=1}^{p} \mathbb{P}(\tau=n \mid X_{n-1}=i)  \mathbb{P}(X_{n-1}=i \mid X_0 =j ) \mathbb{P}(X_0=j)\\
&amp;= \sum_{i=1}^{p} \sum_{j=1}^{p} t_i (T^{n-1} )_{ji} \pi_j\\
&amp;= \sum_{i=1}^{p} \sum_{j=1}^{p} \pi_j (T^{n-1} )_{ji} t_i\\
&amp;= \pi T^{n-1} t.
\end{align*}\]</span></p>
<p>We also need to take possible defect sizes into account. So let <span class="math inline">\(\tau \sim DPH_{p}(\pi,T)\)</span> with defect size <span class="math inline">\(\pi_{p+1}\)</span>, i.e. <span class="math display">\[\begin{equation*}
\tau \sim \begin{cases}
1 &amp; \text{ with probability $\pi_{p+1}$} \\
DPH_{p}(\pi,T) &amp; \text{ with probability $1- \pi_{p+1}$} .
\end{cases}
\end{equation*}\]</span> Then we have that <span class="math display">\[\begin{align*}
\mathbb{P}(\tau= n) &amp;= \mathbb{P}(\tau \cdot 1\kern-.35em1_{\{\tau \geq 1\}}= n)\\
&amp;= \mathbb{P}(\tau(1\kern-.35em1_{\{\tau = 1\}} + 1\kern-.35em1_{\{\tau &gt; 1\}}) = n)\\
&amp;= \mathbb{P}(\tau\cdot 1\kern-.35em1_{\{\tau = 1\}} = n) + \mathbb{P}(\tau\cdot 1\kern-.35em1_{\{\tau &gt; 1\}} = n)
\end{align*}\]</span> Due to the definition of <span class="math inline">\(\tau\)</span>, we know that when <span class="math inline">\(\tau &gt; 1\)</span>, <span class="math inline">\(\tau \sim DPH_{p}(\pi,T)\)</span>. Hence, from the previous computations <span class="math display">\[\begin{equation*}
\mathbb{P}(\tau\cdot 1\kern-.35em1_{\{\tau &gt; 1\}} = n) = \pi T^{n-1} t \quad \text{ for } n\geq 1.
\end{equation*}\]</span> On the other hand, <span class="math display">\[\begin{equation*}
\mathbb{P}(\tau \cdot 1\kern-.35em1_{\{\tau = 1\}} = n) = \mathbb{P}(1 \cdot 1\kern-.35em1_{\{\tau = 1\}} = n) = \begin{cases}
\mathbb{P}(\tau = 1 )=\pi_{p+1}  &amp; \text{ if } n=1\\
0 &amp; \text{ otherwise}.
\end{cases}
\end{equation*}\]</span> This implies that <span class="math display">\[\begin{align*}
\mathbb{P}(\tau= n) &amp;= \mathbb{P}(\tau\cdot 1\kern-.35em1_{\{\tau = 1\}} = n) + \mathbb{P}(\tau\cdot 1\kern-.35em1_{\{\tau &gt; 1\}} = n)\\
&amp;= \begin{cases}
\pi T^{n-1} t + \pi_{p+1}  &amp; \text{ if } n=1\\
\pi T^{n-1} t &amp; \text{ otherwise}.
\end{cases}
\end{align*}\]</span></p>
</div>
<div id="in-the-continuous-case" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case" class="anchor"></a>- in the continuous case</h4>
<p>Now let <span class="math inline">\(\tau= \inf\{t &gt; 0 \mid X_t = p+1\}\)</span> be continuous phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-intensity rate matrix <span class="math inline">\(T\)</span>, <span class="math inline">\(\tau \sim PH_{p}(\pi,T)\)</span>.<br>
Then the density for <span class="math inline">\(\tau\)</span> is given by the derivative of the distribution function (see next section) <span class="math display">\[\begin{align*}
f(u) &amp;= \frac{\partial}{\partial u} F(u)\\
&amp;= \frac{\partial}{\partial u} 1-\pi e^{Tu} \boldsymbol{e} \\
&amp;= -\pi e^{Tu}T \boldsymbol{e}\\
&amp;= \pi e^{Tu}t
\end{align*}\]</span> for <span class="math inline">\(u \geq 0\)</span>, where we have used that <span class="math inline">\(t = -T \boldsymbol{e}\)</span>.</p>
</div>
</div>
<div id="the-distribution-function" class="section level3">
<h3 class="hasAnchor">
<a href="#the-distribution-function" class="anchor"></a>The distribution function</h3>
<div id="in-the-discrete-case-1" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case-1" class="anchor"></a>- in the discrete case</h4>
<p>Let again <span class="math inline">\(\tau= \inf\{t\geq 1 \mid X_t = p+1\}\)</span> be discrete phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-transition probability matrix <span class="math inline">\(T\)</span>, <span class="math inline">\(\tau \sim DPH_{p}(\pi,T)\)</span>.<br>
Then the distribution function for <span class="math inline">\(\tau\)</span> is given by <span class="math display">\[\begin{align*}
F_{\tau}(n) = \mathbb{P}(\tau \leq n) &amp;= 1- \mathbb{P}(\tau &gt; n)\\
&amp;= 1-\sum_{i=1}^{p} \mathbb{P}( X_{n}=i)\\
&amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} \mathbb{P}( X_{n}=i \mid X_0 =j) \mathbb{P}( X_0 =j)
\end{align*}\]</span> for <span class="math inline">\(n \geq 1\)</span>, where the fourth equality is due to the law of total probability. As before, we observe that the probability <span class="math inline">\(\mathbb{P}(X_0=j)\)</span> for the Markov jump process <span class="math inline">\((X_t)_{t\geq 0}\)</span> to start in <span class="math inline">\(j\)</span> is equal to the <span class="math inline">\(j\)</span>’th entry of the initial distribution, and that the probability <span class="math inline">\(\mathbb{P}(X_{n}=i \mid X_0 =j )\)</span> for the process to be in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(n\)</span> given that the process started in state <span class="math inline">\(j\)</span> (or equivalently the probability of going from state <span class="math inline">\(j\)</span> to state <span class="math inline">\(i\)</span> in time <span class="math inline">\(n\)</span>) is given by the <span class="math inline">\((j,i)\)</span>’th element of sub-transition probability matrix <span class="math inline">\(T^{n}\)</span>. Hence, we have that<br><span class="math display">\[\begin{align*}
F_{\tau}(n) &amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} \mathbb{P}( X_{n}=i \mid X_0 =j) \mathbb{P}( X_0 =j)\\
&amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} (T^{n})_{ji}\pi_j\\
&amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} \pi_j(T^{n})_{ji}\\
&amp;= 1- \pi T^{n}\boldsymbol{e}.
\end{align*}\]</span></p>
</div>
<div id="in-the-continuous-case-1" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case-1" class="anchor"></a>- in the continuous case</h4>
<p>As before, let <span class="math inline">\(\tau= \inf\{t &gt; 0 \mid X_t = p+1\}\)</span> be continuous phase-type distributed with initial distribution <span class="math inline">\(\pi\)</span> and sub-intensity rate matrix <span class="math inline">\(T\)</span>, <span class="math inline">\(\tau \sim PH_{p}(\pi,T)\)</span>.<br>
Then the distribution function for <span class="math inline">\(\tau\)</span> is given by <span class="math display">\[\begin{align*}
 F_{\tau}(u) = \mathbb{P}(\tau \leq u) &amp;= 1- \mathbb{P}(\tau &gt; u)\\
&amp;= 1-\sum_{i=1}^{p} \mathbb{P}( X_{u}=i)\\
&amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} \mathbb{P}( X_{u}=i \mid X_0 =j) \mathbb{P}( X_0 =j)
\end{align*}\]</span> for <span class="math inline">\(u \geq 0\)</span>, where the fourth equality is due to the law of total probability. As in the discrete case, we observe that the probability <span class="math inline">\(\mathbb{P}(X_0=j)\)</span> for the Markov jump process <span class="math inline">\((X_t)_{t\geq 0}\)</span> to start in <span class="math inline">\(j\)</span> is equal to the <span class="math inline">\(j\)</span>’th entry of the initial distribution, and that the probability <span class="math inline">\(\mathbb{P}(X_{u}=i \mid X_0 =j )\)</span> for the process to be in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(u\)</span> given that the process started in state <span class="math inline">\(j\)</span> (or equivalently the probability of going from state <span class="math inline">\(j\)</span> to state <span class="math inline">\(i\)</span> in time <span class="math inline">\(u\)</span>) is given by the <span class="math inline">\((j,i)\)</span>’th element of sub-transition probability matrix <span class="math inline">\(e^{Tu}\)</span>. Hence, we have that<br><span class="math display">\[\begin{align*}
F_{\tau}(n) &amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} \mathbb{P}( X_{n}=i \mid X_0 =j) \mathbb{P}( X_0 =j)\\
&amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} (e^{Tu})_{ji}\pi_j\\
&amp;= 1-\sum_{i=1}^{p} \sum_{j=1}^{p} \pi_j(e^{Tu})_{ji}\\
&amp;= 1- \pi e^{Tu}\boldsymbol{e}.
\end{align*}\]</span></p>
</div>
</div>
<div id="the-quantile-function" class="section level3">
<h3 class="hasAnchor">
<a href="#the-quantile-function" class="anchor"></a>The quantile function</h3>
<p>In this package, we used the inbuilt function <code>uniroot</code> to find the quantile for a given probability <span class="math inline">\(p\)</span>. Type <code><a href="https://rdrr.io/r/utils/help.html">help("uniroot")</a></code> into your console to find out more about this function.</p>
</div>
<div id="simulations" class="section level3">
<h3 class="hasAnchor">
<a href="#simulations" class="anchor"></a>Simulations</h3>
<div id="in-the-discrete-case-2" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case-2" class="anchor"></a>- in the discrete case</h4>
<p>For an object of type <code>discphasetype</code> with initial distribution <span class="math inline">\(\pi\)</span> and sub-intensity rate matrix <span class="math inline">\(T\)</span> the simulation is conducted roughly in the following way.</p>
<ul>
<li>The waiting time <span class="math inline">\(\tau\)</span> is set to be <span class="math inline">\(1\)</span>, which corresponds to immediate absorption.</li>
<li>The initial state <span class="math inline">\(X_1\)</span> is sampled from all states according to the initial distribution <span class="math inline">\(\pi\)</span>.</li>
<li>As long as <span class="math inline">\(X_t\)</span> is different from the absorbing state <span class="math inline">\(p+1\)</span>, <span class="math inline">\(t\geq1\)</span>, we add one to the waiting time <span class="math inline">\(\tau\)</span>, i.e. <span class="math inline">\(\tau = \tau +1\)</span>, and the current state <span class="math inline">\(X_t\)</span> is sampled among all states <span class="math inline">\(1,...,p+1\)</span> according to the transition probabilities given in <span class="math inline">\(T\)</span> and the exit rates from <span class="math inline">\(t\)</span>.</li>
</ul>
</div>
<div id="in-the-continuous-case-2" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case-2" class="anchor"></a>- in the continuous case</h4>
<p>For an object of type <code>contphasetype</code> with initial distribution <span class="math inline">\(\pi\)</span> and sub-transition probability matrix <span class="math inline">\(T\)</span> the simulation is conducted roughly in the same way.</p>
<ul>
<li>The waiting time <span class="math inline">\(\tau\)</span> is set to be <span class="math inline">\(0\)</span>, which corresponds to immediate absorption.</li>
<li>The initial state <span class="math inline">\(X_1\)</span> is sampled from all states according to the initial distribution <span class="math inline">\(\pi\)</span>.</li>
<li>As long as <span class="math inline">\(X_t\)</span> is different from the absorbing state <span class="math inline">\(p+1\)</span>, <span class="math inline">\(t\geq1\)</span>, we add an exponential distributed variable to the waiting time <span class="math inline">\(\tau\)</span>, i.e. <span class="math inline">\(\tau = \tau + \lambda\)</span>, where <span class="math inline">\(\lambda \sim \text{Exp}(-T[X_t,X_t])\)</span>. Furthermore, the current state <span class="math inline">\(X_t\)</span> is sampled among all states <span class="math inline">\(1,...,p+1\)</span> (except for the previous state <span class="math inline">\(X_{t-1}\)</span>) according to the rates given in <span class="math inline">\(T\)</span> and the exit rates from <span class="math inline">\(t\)</span>.</li>
</ul>
</div>
<div id="example-8" class="section level4">
<h4 class="hasAnchor">
<a href="#example-8" class="anchor"></a>Example 8</h4>
<p>We want to reproduce Figure 3.4 in John Wakeley (2009): “Coalescent Theory: An Introduction”, Roberts and Company Publishers, Colorado, which displays the distributions of <span class="math inline">\(T_{\text{MRCA}}\)</span> and <span class="math inline">\(T_{\text{Total}}\)</span> for <span class="math inline">\(n \in \{2,5,10,20,50,100\}\)</span>. The initial distributions and sub-intensity rate matrices are stored in the datasets <code>T_MRCA</code> and <code>T_Total</code> that are provided in the package. First, we compute the distribution of <span class="math inline">\(T_{\text{MRCA}}\)</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">## Defining the vector of quantiles</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>t.vec &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="dv">0</span>,<span class="dv">4</span>, <span class="dt">by=</span><span class="fl">0.1</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">## and the matrix holding all distributions</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>dist_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="dt">nrow =</span> <span class="dv">6</span>, <span class="dt">ncol =</span> <span class="kw"><a href="https://rdrr.io/r/base/length.html">length</a></span>(t.vec))</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">## Now we can compute the distributions</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>dist_Mat[<span class="dv">2</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_MRCA<span class="op">$</span>n5, t.vec)</span>
<span id="cb6-10"><a href="#cb6-10"></a>dist_Mat[<span class="dv">3</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_MRCA<span class="op">$</span>n10, t.vec)</span>
<span id="cb6-11"><a href="#cb6-11"></a>dist_Mat[<span class="dv">4</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_MRCA<span class="op">$</span>n20, t.vec)</span>
<span id="cb6-12"><a href="#cb6-12"></a>dist_Mat[<span class="dv">5</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_MRCA<span class="op">$</span>n50, t.vec)</span>
<span id="cb6-13"><a href="#cb6-13"></a>dist_Mat[<span class="dv">6</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_MRCA<span class="op">$</span>n100, t.vec)</span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">## For n=2, the initial distribution is equal to 1 and </span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">## the sub-intensity rate matrix is T_Mat = -1. Hence,</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="co">## the distribution is given by</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>dist_Mat[<span class="dv">1</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>t.vec)</span></code></pre></div>
<p>Now that we have computed the distribution of <span class="math inline">\(T_{\text{MRCA}}\)</span> for all <span class="math inline">\(n\in \{2,5,10,20,50,100\}\)</span> and <span class="math inline">\(t \in \{0,...,4\}\)</span>, we are able to reproduce the first figure</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(t.vec, dist_Mat[<span class="dv">1</span>,], <span class="dt">type =</span> <span class="st">"l"</span>, </span>
<span id="cb7-2"><a href="#cb7-2"></a>     <span class="dt">main =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"The distribution of "</span>, T[<span class="st">"MRCA"</span>], </span>
<span id="cb7-3"><a href="#cb7-3"></a>     <span class="st">" for n=2,5,10,20,50,100"</span>)), <span class="dt">cex.main =</span> <span class="fl">0.9</span>, <span class="dt">xlab =</span> <span class="st">"t"</span>, </span>
<span id="cb7-4"><a href="#cb7-4"></a>     <span class="dt">ylab =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(f[T[MRCA]](t)), <span class="dt">xlim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">4</span>), <span class="dt">ylim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">1</span>), </span>
<span id="cb7-5"><a href="#cb7-5"></a>     <span class="dt">frame.plot =</span> <span class="ot">FALSE</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">2</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">3</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">4</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">5</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">6</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span></code></pre></div>
<p><img src="PhaseTypeGenetics_Mathematical_Details_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<p>Now, we can perform the same calculations for <span class="math inline">\(T_{\text{Total}}\)</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">## Defining the vector of quantiles</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>t.vec &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="dv">0</span>,<span class="dv">15</span>, <span class="dt">by=</span><span class="fl">0.1</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">## and the matrix holding all distributions</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>dist_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="dt">nrow =</span> <span class="dv">6</span>, <span class="dt">ncol =</span> <span class="kw"><a href="https://rdrr.io/r/base/length.html">length</a></span>(t.vec))</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">## Now we can compute the distributions</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>dist_Mat[<span class="dv">2</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_Total<span class="op">$</span>n5, t.vec)</span>
<span id="cb8-10"><a href="#cb8-10"></a>dist_Mat[<span class="dv">3</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_Total<span class="op">$</span>n10, t.vec)</span>
<span id="cb8-11"><a href="#cb8-11"></a>dist_Mat[<span class="dv">4</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_Total<span class="op">$</span>n20, t.vec)</span>
<span id="cb8-12"><a href="#cb8-12"></a>dist_Mat[<span class="dv">5</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_Total<span class="op">$</span>n50, t.vec)</span>
<span id="cb8-13"><a href="#cb8-13"></a>dist_Mat[<span class="dv">6</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dphasetype.html">dphasetype</a></span>(T_Total<span class="op">$</span>n100, t.vec)</span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">## For n=2, the initial distribution is equal to 1 and </span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="co">## the sub-intensity rate matrix is T_Mat = -1/2. Hence,</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="co">## the distribution is given by</span></span>
<span id="cb8-18"><a href="#cb8-18"></a>dist_Mat[<span class="dv">1</span>,] &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span>t.vec<span class="op">/</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">2</span></span></code></pre></div>
<p>Now that we have computed the distribution of <span class="math inline">\(T_{\text{Total}}\)</span> for all <span class="math inline">\(n\in \{2,5,10,20,50,100\}\)</span> and <span class="math inline">\(t \in \{0,...,15\}\)</span>, we are able to reproduce the second figure</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(t.vec, dist_Mat[<span class="dv">1</span>,], <span class="dt">type =</span> <span class="st">"l"</span>, </span>
<span id="cb9-2"><a href="#cb9-2"></a>     <span class="dt">main =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"The distribution of "</span>, T[<span class="st">"Total"</span>], </span>
<span id="cb9-3"><a href="#cb9-3"></a>     <span class="st">" for n=2,5,10,20,50,100"</span>)), <span class="dt">cex.main =</span> <span class="fl">0.9</span>, <span class="dt">xlab =</span> <span class="st">"t"</span>, </span>
<span id="cb9-4"><a href="#cb9-4"></a>     <span class="dt">ylab =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(f[T[Total]](t)), <span class="dt">xlim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">15</span>), <span class="dt">ylim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="fl">0.5</span>), </span>
<span id="cb9-5"><a href="#cb9-5"></a>     <span class="dt">frame.plot =</span> <span class="ot">FALSE</span>)</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">2</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">3</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">4</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">5</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(t.vec, dist_Mat[<span class="dv">6</span>,], <span class="dt">type =</span> <span class="st">"l"</span>)</span></code></pre></div>
<p><img src="PhaseTypeGenetics_Mathematical_Details_files/figure-html/unnamed-chunk-9-1.png" width="700"></p>
<hr>
<p><strong>dSegregatingSites</strong> </p>
<hr>
</div>
</div>
<div id="the-number-of-segregating-sites-s_texttotal" class="section level3">
<h3 class="hasAnchor">
<a href="#the-number-of-segregating-sites-s_texttotal" class="anchor"></a>The number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span>
</h3>
<p>The function <code>dSegregatingSites</code> is another example of a function intended for the use in population genetics. It computes the density of the total number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> for a given sample size <span class="math inline">\(n\)</span> and a mutation parameter <span class="math inline">\(\theta\)</span>. This density can be obtained by the aid of the block counting process together with the reward transformation and the discretization. All of these three topics are discussed in other sections. In short, we obtain the distribution for the waiting time to the most recent common ancestor <span class="math inline">\(\tau_{\text{MRCA}}\)</span> from the block counting process. Then we use the reward transformation to find the distribution of the total branch length <span class="math inline">\(\tau_{\text{Total}}\)</span>. Afterwards, the distribution of the total number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> is computed by the aid of the discretization with <span class="math inline">\(\lambda=\theta/2\)</span> being equal to the mutation rate. Finally, the density is computed using the formula <span class="math display">\[\begin{equation*}
\mathbb{P}(S_{\text{Total}} + 1 = k) = \mathbb{P}(S_{\text{Total}} = k-1) = \pi T^{k-1} t.
\end{equation*}\]</span></p>
<p>The function <code>dSegregatingSites</code> provides a special feature. If <code>plot=TRUE</code>, the function plots the density of the total number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> for the given values of <span class="math inline">\(k\)</span>.<br></p>
<p>Note that this function is based on the package <code>partitions</code>. Make sure to install that package to be able to use <code>dSegregatingSites</code>.</p>
<div id="example-9" class="section level4">
<h4 class="hasAnchor">
<a href="#example-9" class="anchor"></a>Example 9</h4>
<p>We want to reproduce Figure 4.1 in John Wakeley (2009): “Coalescent Theory: An Introduction”, Roberts and Company Publishers, Colorado, which displays the density of the number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> for <span class="math inline">\(n \in \{1,...,20\}\)</span>, <span class="math inline">\(k \in \{0,...,15\}\)</span> and <span class="math inline">\(\theta=2\)</span>. First, we compute the densities using the function <code>dSegregatingSites</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">## We apply the function dSegregatingSites for </span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co">## different quantiles and theta=2</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>k_vec &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">15</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>theta &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co">## Defining a matrix holding all densities</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>Res_Mat &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dSegregatingSites.html">dSegregatingSites</a></span>(<span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">theta =</span> theta, <span class="dt">k =</span> k_vec)</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="co">## and Applying the function for all n in {2,...,20}</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="cf">for</span>(n <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">20</span>){</span>
<span id="cb10-11"><a href="#cb10-11"></a></span>
<span id="cb10-12"><a href="#cb10-12"></a>  Res_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(Res_Mat, <span class="kw"><a href="../reference/dSegregatingSites.html">dSegregatingSites</a></span>(<span class="dt">n =</span> n, <span class="dt">theta =</span> theta, <span class="dt">k =</span> k_vec))</span>
<span id="cb10-13"><a href="#cb10-13"></a>}</span></code></pre></div>
<p>Now that we have calculated all probabilities <span class="math inline">\(\mathbb{P}(S_{\text{Total}} = k)\)</span>, we can produce the desired plot</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co">## We reproduce the plot by using the package plot3D.</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>plot3D<span class="op">::</span><span class="kw"><a href="https://rdrr.io/pkg/plot3D/man/persp3D.html">hist3D</a></span>(<span class="dt">x=</span>k_vec, <span class="dt">y=</span><span class="dv">1</span><span class="op">:</span><span class="dv">20</span>, <span class="dt">z=</span>Res_Mat, <span class="dt">col =</span> <span class="st">"grey"</span>, <span class="dt">border =</span> <span class="st">"black"</span>,</span>
<span id="cb11-4"><a href="#cb11-4"></a>       <span class="dt">xlab =</span> <span class="st">"k"</span>, <span class="dt">ylab =</span> <span class="st">"n"</span>, <span class="dt">zlab =</span> <span class="st">"P(S=k)"</span>,</span>
<span id="cb11-5"><a href="#cb11-5"></a>       <span class="dt">main =</span> <span class="st">"The probability function of the number of segregating sites"</span>,</span>
<span id="cb11-6"><a href="#cb11-6"></a>       <span class="dt">sub =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"The mutation parameter is "</span>, theta,<span class="st">"= 2"</span>)),</span>
<span id="cb11-7"><a href="#cb11-7"></a>       <span class="dt">cex.main =</span> <span class="fl">0.9</span>, <span class="dt">colkey =</span> <span class="ot">FALSE</span>, <span class="dt">zlim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="fl">0.4</span>))</span></code></pre></div>
<p><img src="PhaseTypeGenetics_Mathematical_Details_files/figure-html/unnamed-chunk-11-1.png" width="700"></p>
<hr>
<p><strong>maxima &amp; minima</strong> </p>
<hr>
</div>
</div>
<div id="extrema-of-two-independent-phase-type-distributions" class="section level3">
<h3 class="hasAnchor">
<a href="#extrema-of-two-independent-phase-type-distributions" class="anchor"></a>Extrema of two independent phase-type distributions</h3>
<div id="in-the-discrete-case-3" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case-3" class="anchor"></a>- in the discrete case</h4>
<p>Consider <span class="math inline">\(\tau_1\sim DPH_{p}(\alpha,S)\)</span> and <span class="math inline">\(\tau_2\sim DPH_{q}(\beta,T)\)</span> independent. Then by Theorem 1.2.67 in [BN] <span class="math display">\[\begin{equation*}
\min(\tau_1,\tau_2)\sim DPH_{pq}(\alpha\otimes\beta,S\otimes T),
\end{equation*}\]</span> and <span class="math display">\[\begin{equation*}
\max(\tau_1,\tau_2)\sim DPH_{pq+p+q}(\begin{pmatrix}\alpha\otimes\beta &amp; 0 &amp; 0\end{pmatrix},K).
\end{equation*}\]</span> where <span class="math display">\[\begin{equation*}
K=\begin{pmatrix}S\otimes T &amp; S\otimes t &amp; s\otimes T\\
                  0 &amp; S &amp; 0\\
                  0 &amp; 0 &amp; T\end{pmatrix},
\end{equation*}\]</span> and <span class="math inline">\(s=\boldsymbol{e}-S\boldsymbol{e}\)</span>, <span class="math inline">\(t=\boldsymbol{e}-T\boldsymbol{e}\)</span> are the vectors of exit-probabilities from <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> respectively.<br>
The proof is as follows. Let <span class="math inline">\(\{X_1(n)\}_{n\in\mathbb{N}}\)</span> denote the Markov chain underlying <span class="math inline">\(\tau_1\)</span>. The transition probability matrix of this Markov chain is <span class="math display">\[\begin{equation*}
P_1=\begin{pmatrix}S &amp; s\\ 0 &amp; 1\end{pmatrix}.
\end{equation*}\]</span> Let <span class="math inline">\(\{X_2(n)\}_{n\in\mathbb{N}}\)</span> denote the Markov chain underlying <span class="math inline">\(\tau_2\)</span>. The transition probability matrix of this Markov chain is <span class="math display">\[\begin{equation*}
P_2=\begin{pmatrix}T &amp; t\\ 0 &amp; 1\end{pmatrix}.
\end{equation*}\]</span> <span class="math inline">\(\{Y(n)\}_{n\in\mathbb{N}}=\{(X_1(n),X_2(n))\}_{n\in\mathbb{N}}\)</span> is a Markov Chain on the (lexicographically ordered) product space of the respective state spaces with transition probability matrix <span class="math display">\[\begin{equation*}
P_1\otimes P_2=\begin{pmatrix}S\otimes P_2 &amp; s\otimes P_2 \\
                                0\otimes P_2 &amp; 1\otimes P_2\end{pmatrix}
                =\begin{pmatrix}S\otimes T &amp; S\otimes t &amp; s\otimes T &amp; s\otimes t\\
                                S\otimes 0 &amp; S\otimes 1 &amp; s\otimes 0 &amp; s\otimes 1\\
                                0\otimes T &amp; 0\otimes t &amp; 1\otimes T &amp; 1\otimes t\\
                                0\otimes 0 &amp; 0\otimes 1 &amp; 1\otimes 0 &amp; 1\otimes 1
                \end{pmatrix}
                =\begin{pmatrix}S\otimes T &amp; S\otimes t &amp; s\otimes T &amp; s\otimes t\\
                                0 &amp; S &amp; 0 &amp; s\\
                                0 &amp; 0 &amp; T &amp; t\\
                                0 &amp; 0 &amp; 0 &amp; 1
                \end{pmatrix}.
\end{equation*}\]</span> We can write <span class="math display">\[\begin{equation*}
\max(\tau_1,\tau_2)=\inf\{n\in\mathbb{N}:X_1(n)=p+1\text{ and } X_2(n)=q+1\}=\inf\{n\in\mathbb{N}:Y(n)=(p+1,q+1)\},
\end{equation*}\]</span> meaning that <span class="math inline">\(\max(\tau_1,\tau_2)\)</span> is exactly the stopping for absorption of <span class="math inline">\(\{Y(n)\}_{n\in\mathbb{N}}\)</span> which shows the sub-transition matrix for <span class="math inline">\(\max(\tau_1,\tau_2)\)</span>. From <span class="math inline">\(\{Y(n)\}_{n\in\mathbb{N}}\)</span> we can make yet another Markov chain <span class="math inline">\(\{Z(n)\}_{n\in\mathbb{N}}\)</span> by setting <span class="math display">\[\begin{equation*}Z(n)=\begin{cases}Y(n),&amp; \text{ if } X_1(n)\leq p \text{ and } X_2(n)\leq q,\\
                    (p+1,1),&amp; \text{otherwise}\end{cases}.
\end{equation*}\]</span> Then <span class="math inline">\(\{Z(n)\}_{n\in\mathbb{N}}\)</span> is a Markov Chain with transition probability matrix <span class="math display">\[\begin{equation*}\begin{pmatrix}S\otimes T &amp; r\\
                 0 &amp; 1\end{pmatrix},\end{equation*}\]</span> where <span class="math inline">\(r=e-(S\otimes T)e\)</span>. We can write <span class="math display">\[\begin{equation*}\min(\tau_1,\tau_2)=\inf\{n\in\mathbb{N}:X_1(n)&gt;p\text{ and } X_2(n)&gt;q\}=\inf\{n\in\mathbb{N}:Z(n)=(p+1,1)\},
\end{equation*}\]</span>meaning that <span class="math inline">\(\min(\tau_1,\tau_2)\)</span> is exactly the stopping for absorption of <span class="math inline">\(\{Z(n)\}_{n\in\mathbb{N}}\)</span> which shows the sub-transition matrix for <span class="math inline">\(\min(\tau_1,\tau_2)\)</span>.<br>
Initializing <span class="math inline">\(\{Y(n)\}_{n\in\mathbb{N}}\)</span> with <span class="math inline">\(\begin{pmatrix}\alpha\otimes\beta &amp; 0 &amp; 0 &amp; 0\end{pmatrix}\)</span> and <span class="math inline">\(\{Z(n)\}_{n\in\mathbb{N}}\)</span> with <span class="math inline">\(\begin{pmatrix}\alpha\otimes\beta &amp; 0\end{pmatrix}\)</span>, is precisely the way to initialize the underlying <span class="math inline">\(\{X_1(n)\}_{n\in\mathbb{N}}\)</span> and <span class="math inline">\(\{X_2(n)\}_{n\in\mathbb{N}}\)</span> with <span class="math inline">\(\begin{pmatrix}\alpha &amp; 0\end{pmatrix}\)</span> and <span class="math inline">\(\begin{pmatrix}\beta &amp; 0\end{pmatrix}\)</span> respectively.<br>
This theorem is implemented in the <code>minima</code>- and <code>maxima</code>-functions. They take two phase-type objects as input and if both of these are of the <code>discphasetype</code>-class, then they each output an object of the <code>discphasetype</code>-class with parameters calculated from the parameters of the given objects in accordance with the above theorem.</p>
</div>
<div id="example-10" class="section level4">
<h4 class="hasAnchor">
<a href="#example-10" class="anchor"></a>Example 10</h4>
<p>Let’s run the functions on pair of discrete phase-type distributions</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a> tau1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">discphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">5</span>,.<span class="dv">2</span>,.<span class="dv">3</span>),</span>
<span id="cb12-2"><a href="#cb12-2"></a>                                <span class="dt">P_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">1</span>,.<span class="dv">3</span>,.<span class="dv">2</span>,.<span class="dv">3</span>,.<span class="dv">2</span>,.<span class="dv">1</span>,.<span class="dv">2</span>,.<span class="dv">1</span>,.<span class="dv">3</span>), </span>
<span id="cb12-3"><a href="#cb12-3"></a>                                               <span class="dt">nrow =</span> <span class="dv">3</span>))</span>
<span id="cb12-4"><a href="#cb12-4"></a>tau2 =<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">discphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">2</span>,.<span class="dv">7</span>), </span>
<span id="cb12-5"><a href="#cb12-5"></a>                                  <span class="dt">P_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">5</span>,<span class="dv">0</span>,.<span class="dv">3</span>,.<span class="dv">2</span>), <span class="dt">nrow =</span> <span class="dv">2</span>))</span></code></pre></div>
<p>Plugging these into <code>minima</code> and <code>maxima</code> we get</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>  <span class="kw"><a href="../reference/minima.html">minima</a></span>(tau1,tau2)</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">#&gt; [1] 0.10 0.35 0.04 0.14 0.06 0.21</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co">#&gt; </span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">#&gt; [1,] 0.05 0.03 0.15 0.09 0.10 0.06</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="co">#&gt; [2,] 0.00 0.02 0.00 0.06 0.00 0.04</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="co">#&gt; [3,] 0.15 0.09 0.10 0.06 0.05 0.03</span></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="co">#&gt; [4,] 0.00 0.06 0.00 0.04 0.00 0.02</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="co">#&gt; [5,] 0.10 0.06 0.05 0.03 0.15 0.09</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="co">#&gt; [6,] 0.00 0.04 0.00 0.02 0.00 0.06</span></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="co">#&gt; </span></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="co">#&gt; [1] "discphasetype"</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>  <span class="kw"><a href="../reference/minima.html">maxima</a></span>(tau1,tau2) </span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="co">#&gt;  [1] 0.10 0.35 0.04 0.14 0.06 0.21 0.00 0.00 0.00 0.00 0.00</span></span>
<span id="cb13-19"><a href="#cb13-19"></a><span class="co">#&gt; </span></span>
<span id="cb13-20"><a href="#cb13-20"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb13-21"><a href="#cb13-21"></a><span class="co">#&gt;       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]</span></span>
<span id="cb13-22"><a href="#cb13-22"></a><span class="co">#&gt;  [1,] 0.05 0.03 0.15 0.09 0.10 0.06 0.02 0.06 0.04   0.2  0.12</span></span>
<span id="cb13-23"><a href="#cb13-23"></a><span class="co">#&gt;  [2,] 0.00 0.02 0.00 0.06 0.00 0.04 0.08 0.24 0.16   0.0  0.08</span></span>
<span id="cb13-24"><a href="#cb13-24"></a><span class="co">#&gt;  [3,] 0.15 0.09 0.10 0.06 0.05 0.03 0.06 0.04 0.02   0.2  0.12</span></span>
<span id="cb13-25"><a href="#cb13-25"></a><span class="co">#&gt;  [4,] 0.00 0.06 0.00 0.04 0.00 0.02 0.24 0.16 0.08   0.0  0.08</span></span>
<span id="cb13-26"><a href="#cb13-26"></a><span class="co">#&gt;  [5,] 0.10 0.06 0.05 0.03 0.15 0.09 0.04 0.02 0.06   0.2  0.12</span></span>
<span id="cb13-27"><a href="#cb13-27"></a><span class="co">#&gt;  [6,] 0.00 0.04 0.00 0.02 0.00 0.06 0.16 0.08 0.24   0.0  0.08</span></span>
<span id="cb13-28"><a href="#cb13-28"></a><span class="co">#&gt;  [7,] 0.00 0.00 0.00 0.00 0.00 0.00 0.10 0.30 0.20   0.0  0.00</span></span>
<span id="cb13-29"><a href="#cb13-29"></a><span class="co">#&gt;  [8,] 0.00 0.00 0.00 0.00 0.00 0.00 0.30 0.20 0.10   0.0  0.00</span></span>
<span id="cb13-30"><a href="#cb13-30"></a><span class="co">#&gt;  [9,] 0.00 0.00 0.00 0.00 0.00 0.00 0.20 0.10 0.30   0.0  0.00</span></span>
<span id="cb13-31"><a href="#cb13-31"></a><span class="co">#&gt; [10,] 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00   0.5  0.30</span></span>
<span id="cb13-32"><a href="#cb13-32"></a><span class="co">#&gt; [11,] 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00   0.0  0.20</span></span>
<span id="cb13-33"><a href="#cb13-33"></a><span class="co">#&gt; </span></span>
<span id="cb13-34"><a href="#cb13-34"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb13-35"><a href="#cb13-35"></a><span class="co">#&gt; [1] "discphasetype"</span></span></code></pre></div>
</div>
<div id="in-the-continuous-case-3" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case-3" class="anchor"></a>- in the continuous case</h4>
Consider <span class="math inline">\(X\sim PH_{p}(\alpha,S)\)</span> and <span class="math inline">\(Y\sim PH_{q}(\beta,T)\)</span> independent. Then by Corollary 3.1.32 in [BN] <span class="math display">\[\begin{equation*}
\min(X,Y)\sim PH_{pq}(\alpha\otimes\beta,S\oplus T),
\end{equation*}\]</span> and <span class="math display">\[\begin{equation*}
\max(X,Y)\sim PH_{pq+p+q}(\begin{pmatrix}\alpha\otimes\beta &amp; 0 &amp; 0\end{pmatrix},K).
\end{equation*}\]</span> where <span class="math display">\[\begin{equation*}K=\begin{pmatrix}S\oplus T &amp; I\otimes t &amp; s\otimes I\\
                  0 &amp; S &amp; 0\\
                  0 &amp; 0 &amp; T\end{pmatrix},
\end{equation*}\]</span> and <span class="math inline">\(s=-S\boldsymbol{e}\)</span> as well as <span class="math inline">\(t=-T\boldsymbol{e}\)</span> are the vectors of exit-rates from <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span>, respectively, and <span class="math inline">\(\oplus\)</span> is the Kronecker sum given by <span class="math inline">\(A \oplus B =A\otimes I_{\text{dim}(B)} + I_{\text{dim}(A)}\otimes B\)</span>.<br>
The proof is as follows. Let <span class="math inline">\(\{X_1(t)\}_{t\geq0}\)</span> denote the Markov Jump Process underlying <span class="math inline">\(X\)</span>. The rate matrix of this Markov Jump Process is <span class="math display">\[\begin{equation*}
Q_1=\begin{pmatrix}S &amp; s\\ 0 &amp; 0\end{pmatrix}.
\end{equation*}\]</span> Let <span class="math inline">\(\{Y_1(t)\}_{t\geq0}\)</span> denote the Markov Jump Process underlying <span class="math inline">\(Y\)</span>. The rate matrix of this Markov Jump Process is <span class="math display">\[\begin{equation*}
Q_2=\begin{pmatrix}T &amp; t\\ 0 &amp; 0\end{pmatrix}.
\end{equation*}\]</span> <span class="math inline">\(\{Z(t)\}_{t\geq0}=\{(X_1(t),Y_1(t))\}_{t\geq0}\)</span> is a Markov Jump Process on the (lexicographically ordered) product space of the respective state spaces with rate matrix <span class="math display">\[\begin{equation*}Q_1\oplus Q_2=\begin{pmatrix}S\oplus T &amp; I\otimes t &amp; s\otimes I &amp; 0\\
                                0 &amp; S &amp; 0 &amp; s\\
                                0 &amp; 0 &amp; T &amp; t\\
                                0 &amp; 0 &amp; 0 &amp; 0
                \end{pmatrix}.
\end{equation*}\]</span> We can write <span class="math display">\[\begin{equation*}\max(X,Y)=\inf\{t\geq0\in\mathbb{N}:X_1(t)=p+1\text{ and } Y_1(t)=q+1\}=\inf\{t\geq0:Z(t)=(p+1,q+1)\},
\end{equation*}\]</span> meaning that <span class="math inline">\(\max(X,Y)\)</span> is exactly the stopping time for absorption of <span class="math inline">\(\{Z(t)\}_{t\geq0}\)</span> which shows the sub-intensity matrix for <span class="math inline">\(\max(X,Y)\)</span>. From <span class="math inline">\(\{Z(t)\}_{t\geq0}=\{(X_1(t),Y_1(t))\}_{t\geq0}\)</span> we can make yet another Markov Jump Process <span class="math inline">\(\{W(t)\}_{t\geq0}\)</span> by setting \begin{equation<em>W(t)=\begin{cases}Y(t),&amp;  X_1(t)p  Y_1(t)q,\ (p+1,1),&amp; \end{cases}. \end{equation</em>} Then <span class="math inline">\(\{W(t)\}_{t\geq0}\)</span> is a Markov Jump Process with rate matrix \begin{equation*
<span class="math display">\[\begin{pmatrix}S\oplus T &amp; r\\
                 0 &amp; 1\end{pmatrix}\]</span>
<p>, \end{equation*} where <span class="math inline">\(r=e-(S\oplus T)e\)</span>. We can write <span class="math display">\[\begin{equation*}\min(X,Y)=\inf\{t\geq0:X_1(t)&gt;p\text{ and } Y_1(t)&gt;q\}=\inf\{t\geq0:W(t)=(p+1,1)\},
\end{equation*}\]</span> meaning that <span class="math inline">\(\min(X,Y)\)</span> is exactly the stopping time for absorption of <span class="math inline">\(\{W(t)\}_{t\geq0}\)</span> which shows the sub-intensity matrix for <span class="math inline">\(\min(X,Y)\)</span>.<br>
Initializing <span class="math inline">\(\{Z(t)\}_{t\geq0}\)</span> with <span class="math inline">\(\begin{pmatrix}\alpha\otimes\beta &amp; 0 &amp; 0 &amp; 0\end{pmatrix}\)</span> and <span class="math inline">\(\{W(t)\}_{t\geq0}\)</span> with <span class="math inline">\(\begin{pmatrix}\alpha\otimes\beta &amp; 0\end{pmatrix}\)</span>, is precisely the way to initialize the underlying <span class="math inline">\(\{X_1(t)\}_{t\geq0}\)</span> and <span class="math inline">\(\{Y_1(t)\}_{t\geq0}\)</span> with <span class="math inline">\(\begin{pmatrix}\alpha &amp; 0\end{pmatrix}\)</span> and <span class="math inline">\(\begin{pmatrix}\beta &amp; 0\end{pmatrix}\)</span> respectively.<br>
This result is implemented in the <code>phasemin</code> and <code>phasemax</code> functions. They take two phase-type objects as input and if both of these are of the <code>contphasetype</code>class, then they each output an object of the <code>contphasetype</code>class with parameters calculated from the parameters of the given objects in accordance with the above theorem.</p>
</div>
<div id="example-11" class="section level4">
<h4 class="hasAnchor">
<a href="#example-11" class="anchor"></a>Example 11</h4>
<p>Let’s run the functions on a pair of continuous phase-type distributions</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>x_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">12</span>,.<span class="dv">53</span>,.<span class="dv">24</span>),</span>
<span id="cb14-2"><a href="#cb14-2"></a>                                 <span class="dt">T_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">5</span>), <span class="dt">nrow =</span> <span class="dv">3</span>))</span>
<span id="cb14-3"><a href="#cb14-3"></a>x_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">7</span>,.<span class="dv">3</span>),</span>
<span id="cb14-4"><a href="#cb14-4"></a>                                <span class="dt">T_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">4</span>), <span class="dt">nrow =</span> <span class="dv">2</span>))</span></code></pre></div>
<p>Plugging these into <code>minima</code> and <code>maxima</code> we get</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>  <span class="kw"><a href="../reference/minima.html">minima</a></span>(x_<span class="dv">1</span>,x_<span class="dv">2</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">#&gt; [1] 0.084 0.036 0.371 0.159 0.168 0.072</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co">#&gt; </span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co">#&gt; $T_Mat</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="co">#&gt; [1,]   -8    2    2    0    2    0</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="co">#&gt; [2,]    1  -10    0    2    0    2</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="co">#&gt; [3,]    1    0  -10    2    3    0</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="co">#&gt; [4,]    0    1    1  -12    0    3</span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="co">#&gt; [5,]    1    0    0    0   -7    2</span></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="co">#&gt; [6,]    0    1    0    0    1   -9</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="co">#&gt; </span></span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb15-15"><a href="#cb15-15"></a><span class="co">#&gt; [1] "contphasetype"</span></span>
<span id="cb15-16"><a href="#cb15-16"></a>  <span class="kw"><a href="../reference/minima.html">maxima</a></span>(x_<span class="dv">1</span>,x_<span class="dv">2</span>)</span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb15-18"><a href="#cb15-18"></a><span class="co">#&gt;  [1] 0.084 0.036 0.371 0.159 0.168 0.072 0.000 0.000 0.000 0.000 0.000</span></span>
<span id="cb15-19"><a href="#cb15-19"></a><span class="co">#&gt; </span></span>
<span id="cb15-20"><a href="#cb15-20"></a><span class="co">#&gt; $T_Mat</span></span>
<span id="cb15-21"><a href="#cb15-21"></a><span class="co">#&gt;       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]</span></span>
<span id="cb15-22"><a href="#cb15-22"></a><span class="co">#&gt;  [1,]   -8    2    2    0    2    0    0    0    0     2     0</span></span>
<span id="cb15-23"><a href="#cb15-23"></a><span class="co">#&gt;  [2,]    1  -10    0    2    0    2    3    0    0     0     2</span></span>
<span id="cb15-24"><a href="#cb15-24"></a><span class="co">#&gt;  [3,]    1    0  -10    2    3    0    0    0    0     4     0</span></span>
<span id="cb15-25"><a href="#cb15-25"></a><span class="co">#&gt;  [4,]    0    1    1  -12    0    3    0    3    0     0     4</span></span>
<span id="cb15-26"><a href="#cb15-26"></a><span class="co">#&gt;  [5,]    1    0    0    0   -7    2    0    0    0     4     0</span></span>
<span id="cb15-27"><a href="#cb15-27"></a><span class="co">#&gt;  [6,]    0    1    0    0    1   -9    0    0    3     0     4</span></span>
<span id="cb15-28"><a href="#cb15-28"></a><span class="co">#&gt;  [7,]    0    0    0    0    0    0   -6    2    2     0     0</span></span>
<span id="cb15-29"><a href="#cb15-29"></a><span class="co">#&gt;  [8,]    0    0    0    0    0    0    1   -8    3     0     0</span></span>
<span id="cb15-30"><a href="#cb15-30"></a><span class="co">#&gt;  [9,]    0    0    0    0    0    0    1    0   -5     0     0</span></span>
<span id="cb15-31"><a href="#cb15-31"></a><span class="co">#&gt; [10,]    0    0    0    0    0    0    0    0    0    -2     2</span></span>
<span id="cb15-32"><a href="#cb15-32"></a><span class="co">#&gt; [11,]    0    0    0    0    0    0    0    0    0     1    -4</span></span>
<span id="cb15-33"><a href="#cb15-33"></a><span class="co">#&gt; </span></span>
<span id="cb15-34"><a href="#cb15-34"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb15-35"><a href="#cb15-35"></a><span class="co">#&gt; [1] "contphasetype"</span></span></code></pre></div>
<hr>
<p><strong>phmean &amp; phvar</strong> </p>
<hr>
</div>
</div>
<div id="mean-and-variance" class="section level3">
<h3 class="hasAnchor">
<a href="#mean-and-variance" class="anchor"></a>Mean and variance</h3>
<p>The expression for the mean and variance of a phase-type distribution follows directly from the expression of the (factorial) moments (See section <em>Moments and factorial moments</em>).</p>
<div id="in-the-discrete-case-4" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case-4" class="anchor"></a>- in the discrete case</h4>
<p>Let <span class="math inline">\(\tau \sim \text{DPH}(\pi,T)\)</span>. Then the factorial moments are given by <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau(\tau -1) \cdots (\tau-k+1)] = k!\pi T^{k-1}(I-T)^{-k}e.
\end{equation*}\]</span> From this equality it follows that <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau] = \pi (I-T)^{-1} e
\end{equation*}\]</span> and that <span class="math display">\[\begin{align*}
\mathbb{V}\text{ar}[\tau] &amp;= \mathbb{E}[\tau^2]- \mathbb{E}[\tau]^2\\
&amp;= \mathbb{E}[\tau^2]- \mathbb{E}[\tau] +  \mathbb{E}[\tau]- \mathbb{E}[\tau]^2\\
&amp;= \mathbb{E}[\tau^2- \tau] +  \mathbb{E}[\tau]- \mathbb{E}[\tau]^2\\
&amp;= \mathbb{E}[\tau(\tau-1)] +  \mathbb{E}[\tau]- \mathbb{E}[\tau]^2\\
&amp;= 2\pi T(I-T)^{-2}e + \pi (I-T)^{-1} e - \big( \pi (I-T)^{-1} e\big)^2.
\end{align*}\]</span></p>
</div>
<div id="in-the-continuous-case-4" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case-4" class="anchor"></a>- in the continuous case</h4>
<p>Let <span class="math inline">\(\tau \sim \text{PH}(\pi,T)\)</span>. Then the <span class="math inline">\(n\)</span>’th order moment of <span class="math inline">\(\tau\)</span> is given as <span class="math display">\[\begin{align*}
\mathbb{E}[\tau^n] =  n! \pi (-T)^{-n}e.
\end{align*}\]</span> From this equation it follows that <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau] =  \pi (-T)^{-1}e
\end{equation*}\]</span> and that <span class="math display">\[\begin{equation*}
\mathbb{V}\text{ar}[\tau] =  \mathbb{E}[\tau^2]- \mathbb{E}[\tau]^2 = 2 \pi (-T)^{-2}e - \big( \pi (-T)^{-1}e \big)^2.
\end{equation*}\]</span></p>
</div>
<div id="example-12" class="section level4">
<h4 class="hasAnchor">
<a href="#example-12" class="anchor"></a>Example 12</h4>
<p>We want to reproduce Figure 3.3 in John Wakeley (2009): “Coalescent Theory: An Introduction”, Roberts and Company Publishers, Colorado, which displays the dependence of <span class="math inline">\(\mathbb{E}[\tau_{\text{MRCA}}]\)</span> and <span class="math inline">\(\mathbb{E}[\tau_{\text{Total}}]\)</span> on the sample size <span class="math inline">\(n\)</span>.<br>
We begin with a sample size of <span class="math inline">\(n=2\)</span>. In that case, the initial distribution is <span class="math inline">\(\pi=1\)</span> and the sub-transition probability matrix is equal to -1 for the waiting time to the most recent common ancestor <span class="math inline">\(\tau_{\text{MRCA}}\)</span> and <span class="math inline">\(-\tfrac{1}{2}\)</span> for the total branch length <span class="math inline">\(\tau_{\text{Total}}\)</span>. Therefore, the means are given as <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau_{\text{MRCA}}] =  \pi (-T)^{-1}e = 1 (-(-1))^{-1} 1 = 1
\end{equation*}\]</span> and <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau_{\text{Total}}] =  \pi (-T)^{-1}e = 1 (-(-\tfrac{1}{2}))^{-1} 1 = 2
\end{equation*}\]</span> while the variances are <span class="math display">\[\begin{equation*}
\mathbb{V}\text{ar}[\tau_{\text{MRCA}}] =  2 \pi (-T)^{-2}e - \big( \pi (-T)^{-1}e \big)^2 = 2 \cdot 1 \cdot (-(-1))^{-2} \cdot 1 - 1^2 = 2-1 = 1
\end{equation*}\]</span> and <span class="math display">\[\begin{equation*}
\mathbb{V}\text{ar}[\tau_{\text{Total}}] = 2 \pi (-T)^{-2}e - \big( \pi (-T)^{-1}e \big)^2 = 2 \cdot 1 \cdot (-(-\tfrac{1}{2}))^{-2} \cdot 1 - 2^2 = 8-4 = 4.
\end{equation*}\]</span> For a sample size of <span class="math inline">\(n\geq 3\)</span>, we can compute the mean and variances using the functions <code>phmean</code> and <code>phvar</code>, respectively.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">## We define vectors holding the means and variances</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>VecOfMeansMRCA &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(<span class="dv">20</span>,<span class="dv">0</span>)</span>
<span id="cb16-3"><a href="#cb16-3"></a>VecOfVarsMRCA &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(<span class="dv">20</span>,<span class="dv">0</span>)</span>
<span id="cb16-4"><a href="#cb16-4"></a>VecOfMeansTotal &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(<span class="dv">20</span>,<span class="dv">0</span>)</span>
<span id="cb16-5"><a href="#cb16-5"></a>VecOfVarsTotal &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(<span class="dv">20</span>,<span class="dv">0</span>)</span>
<span id="cb16-6"><a href="#cb16-6"></a></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">## For n=2, </span></span>
<span id="cb16-8"><a href="#cb16-8"></a>VecOfMeansMRCA[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">1</span> </span>
<span id="cb16-9"><a href="#cb16-9"></a>VecOfMeansTotal[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">2</span> </span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="co">## and </span></span>
<span id="cb16-11"><a href="#cb16-11"></a>VecOfVarsMRCA[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">1</span> </span>
<span id="cb16-12"><a href="#cb16-12"></a>VecOfVarsTotal[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">4</span> </span>
<span id="cb16-13"><a href="#cb16-13"></a></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="co">## For n=3,</span></span>
<span id="cb16-15"><a href="#cb16-15"></a>initDist =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="co">## and </span></span>
<span id="cb16-17"><a href="#cb16-17"></a>T_Mat_MRCA =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb16-18"><a href="#cb16-18"></a>T_Mat_Total =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb16-19"><a href="#cb16-19"></a></span>
<span id="cb16-20"><a href="#cb16-20"></a><span class="co">## Defining two objects of class "contphasetype"</span></span>
<span id="cb16-21"><a href="#cb16-21"></a>TMRCA &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(initDist, T_Mat_MRCA)</span>
<span id="cb16-22"><a href="#cb16-22"></a>TTotal &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(initDist, T_Mat_Total)</span>
<span id="cb16-23"><a href="#cb16-23"></a><span class="co">## Hence the means are given by</span></span>
<span id="cb16-24"><a href="#cb16-24"></a>VecOfMeansMRCA[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phmean</a></span>(TMRCA)</span>
<span id="cb16-25"><a href="#cb16-25"></a>VecOfMeansTotal[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phmean</a></span>(TTotal)</span>
<span id="cb16-26"><a href="#cb16-26"></a><span class="co">## and the variances are</span></span>
<span id="cb16-27"><a href="#cb16-27"></a>VecOfVarsMRCA[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phvar</a></span>(TMRCA)</span>
<span id="cb16-28"><a href="#cb16-28"></a>VecOfVarsTotal[<span class="dv">3</span>] &lt;-<span class="kw"><a href="../reference/phmean.html">phvar</a></span>(TTotal)</span>
<span id="cb16-29"><a href="#cb16-29"></a></span>
<span id="cb16-30"><a href="#cb16-30"></a><span class="co">## For n&gt;3, </span></span>
<span id="cb16-31"><a href="#cb16-31"></a><span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">4</span><span class="op">:</span><span class="dv">20</span>) {</span>
<span id="cb16-32"><a href="#cb16-32"></a>  </span>
<span id="cb16-33"><a href="#cb16-33"></a>  <span class="co">## For T_MRCA</span></span>
<span id="cb16-34"><a href="#cb16-34"></a>  <span class="co">## The initial distribution</span></span>
<span id="cb16-35"><a href="#cb16-35"></a>  initDist &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>,<span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(n<span class="dv">-2</span>,<span class="dv">0</span>))</span>
<span id="cb16-36"><a href="#cb16-36"></a>  <span class="co">## The subi-ntensity rate matrix</span></span>
<span id="cb16-37"><a href="#cb16-37"></a>  T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/Special.html">choose</a></span>(n<span class="op">:</span><span class="dv">3</span>,<span class="dv">2</span>))</span>
<span id="cb16-38"><a href="#cb16-38"></a>  T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(n<span class="dv">-2</span>,<span class="dv">0</span>),T_Mat)</span>
<span id="cb16-39"><a href="#cb16-39"></a>  T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span>(T_Mat, <span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(n<span class="dv">-1</span>,<span class="dv">0</span>))</span>
<span id="cb16-40"><a href="#cb16-40"></a>  <span class="kw"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(T_Mat) &lt;-<span class="st"> </span><span class="op">-</span><span class="kw"><a href="https://rdrr.io/r/base/Special.html">choose</a></span>(n<span class="op">:</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb16-41"><a href="#cb16-41"></a>  <span class="co">## Define an object of class "contphasetype"</span></span>
<span id="cb16-42"><a href="#cb16-42"></a>  obj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(initDist,T_Mat)</span>
<span id="cb16-43"><a href="#cb16-43"></a>  <span class="co">## Compute the mean and variance</span></span>
<span id="cb16-44"><a href="#cb16-44"></a>  VecOfMeansMRCA[n] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phmean</a></span>(obj)</span>
<span id="cb16-45"><a href="#cb16-45"></a>  VecOfVarsMRCA[n] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phvar</a></span>(obj)</span>
<span id="cb16-46"><a href="#cb16-46"></a></span>
<span id="cb16-47"><a href="#cb16-47"></a>  <span class="co">## For T_total,</span></span>
<span id="cb16-48"><a href="#cb16-48"></a>  <span class="co">## the sub-intensity rate matrix is</span></span>
<span id="cb16-49"><a href="#cb16-49"></a>  T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>((n<span class="dv">-1</span>)<span class="op">:</span><span class="dv">2</span>)</span>
<span id="cb16-50"><a href="#cb16-50"></a>  T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(n<span class="dv">-2</span>,<span class="dv">0</span>),T_Mat)</span>
<span id="cb16-51"><a href="#cb16-51"></a>  T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span>(T_Mat, <span class="kw"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span>(n<span class="dv">-1</span>,<span class="dv">0</span>))</span>
<span id="cb16-52"><a href="#cb16-52"></a>  <span class="kw"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(T_Mat) &lt;-<span class="st"> </span><span class="op">-</span>((n<span class="dv">-1</span>)<span class="op">:</span><span class="dv">1</span>)</span>
<span id="cb16-53"><a href="#cb16-53"></a>  T_Mat &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>T_Mat</span>
<span id="cb16-54"><a href="#cb16-54"></a>  <span class="co">## Define an object of class "contphasetype"</span></span>
<span id="cb16-55"><a href="#cb16-55"></a>  obj &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(initDist,T_Mat)</span>
<span id="cb16-56"><a href="#cb16-56"></a>  <span class="co">## Compute the mean and variance</span></span>
<span id="cb16-57"><a href="#cb16-57"></a>  VecOfMeansTotal[n] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phmean</a></span>(obj)</span>
<span id="cb16-58"><a href="#cb16-58"></a>  VecOfVarsTotal[n] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/phmean.html">phvar</a></span>(obj)</span>
<span id="cb16-59"><a href="#cb16-59"></a>}</span>
<span id="cb16-60"><a href="#cb16-60"></a></span>
<span id="cb16-61"><a href="#cb16-61"></a><span class="co">## Plotting the means</span></span>
<span id="cb16-62"><a href="#cb16-62"></a><span class="kw"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>, VecOfMeansMRCA, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">main =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"The dependence of "</span>,<span class="kw">E</span>(T[MRCA]),<span class="st">" and "</span>, <span class="kw">E</span>(T[Total]), <span class="st">" on the sample size"</span>)), </span>
<span id="cb16-63"><a href="#cb16-63"></a>     <span class="dt">cex.main =</span> <span class="fl">0.9</span>, <span class="dt">xlab =</span> <span class="st">"n"</span>, <span class="dt">ylab =</span> <span class="st">"Expectation"</span>,</span>
<span id="cb16-64"><a href="#cb16-64"></a>     <span class="dt">xlim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">25</span>), <span class="dt">ylim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">8</span>), <span class="dt">frame.plot =</span> <span class="ot">FALSE</span>)</span>
<span id="cb16-65"><a href="#cb16-65"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(<span class="dt">x=</span> <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>, VecOfMeansTotal, <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb16-66"><a href="#cb16-66"></a></span>
<span id="cb16-67"><a href="#cb16-67"></a><span class="kw"><a href="https://rdrr.io/r/graphics/text.html">text</a></span>(<span class="dv">23</span>,<span class="kw"><a href="https://rdrr.io/r/utils/head.html">tail</a></span>(VecOfMeansMRCA, <span class="dt">n=</span><span class="dv">1</span>),<span class="dt">labels =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw">E</span>(T[MRCA])))</span>
<span id="cb16-68"><a href="#cb16-68"></a><span class="kw"><a href="https://rdrr.io/r/graphics/text.html">text</a></span>(<span class="dv">23</span>,<span class="kw"><a href="https://rdrr.io/r/utils/head.html">tail</a></span>(VecOfMeansTotal, <span class="dt">n=</span><span class="dv">1</span>),<span class="dt">labels =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw">E</span>(T[Total])))</span></code></pre></div>
<p><img src="PhaseTypeGenetics_Mathematical_Details_files/figure-html/unnamed-chunk-16-1.png" width="700"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="co">## And plotting the variances</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>, VecOfVarsMRCA, <span class="dt">type =</span> <span class="st">"l"</span>, <span class="dt">main =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/paste.html">paste</a></span>(<span class="st">"The dependence of "</span>,<span class="kw">Var</span>(T[MRCA]),<span class="st">" and "</span>, <span class="kw">Var</span>(T[Total]), <span class="st">" on the sample size"</span>)), </span>
<span id="cb17-4"><a href="#cb17-4"></a>     <span class="dt">cex.main =</span> <span class="fl">0.9</span>, <span class="dt">xlab =</span> <span class="st">"n"</span>, <span class="dt">ylab =</span> <span class="st">"Variance"</span>,</span>
<span id="cb17-5"><a href="#cb17-5"></a>     <span class="dt">xlim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">25</span>), <span class="dt">ylim =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">7</span>), <span class="dt">frame.plot =</span> <span class="ot">FALSE</span>)</span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw"><a href="https://rdrr.io/r/graphics/points.html">points</a></span>(<span class="dt">x=</span> <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>, VecOfVarsTotal, <span class="dt">type =</span> <span class="st">"l"</span>)</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="kw"><a href="https://rdrr.io/r/graphics/text.html">text</a></span>(<span class="dv">23</span>,<span class="kw"><a href="https://rdrr.io/r/utils/head.html">tail</a></span>(VecOfVarsMRCA, <span class="dt">n=</span><span class="dv">1</span>),<span class="dt">labels =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw">Var</span>(T[MRCA])))</span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="kw"><a href="https://rdrr.io/r/graphics/text.html">text</a></span>(<span class="dv">23</span>,<span class="kw"><a href="https://rdrr.io/r/utils/head.html">tail</a></span>(VecOfVarsTotal, <span class="dt">n=</span><span class="dv">1</span>),<span class="dt">labels =</span> <span class="kw"><a href="https://rdrr.io/r/base/expression.html">expression</a></span>(<span class="kw">Var</span>(T[Total])))</span></code></pre></div>
<p><img src="PhaseTypeGenetics_Mathematical_Details_files/figure-html/unnamed-chunk-16-2.png" width="700"></p>
<hr>
<p><strong>moments</strong> </p>
<hr>
</div>
</div>
<div id="moments-and-factorial-moments" class="section level3">
<h3 class="hasAnchor">
<a href="#moments-and-factorial-moments" class="anchor"></a>Moments and factorial moments</h3>
<p>In this section, we consider the (factorial) moments of phase-type distributions. In the continuous case, we are able to compute the moments directly using the Laplace transform, but in the discrete case, we have to consider factorial moments instead.</p>
<div id="in-the-discrete-case-5" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case-5" class="anchor"></a>- in the discrete case</h4>
<p>Let <span class="math inline">\(\tau \sim \text{DPH}(\pi,T)\)</span>. Then we have that the factorial moments are given by <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau(\tau -1) \cdots (\tau-k+1)] = k!\pi T^{k-1}(I-T)^{-k}e,
\end{equation*}\]</span> where <span class="math inline">\(k\geq 1\)</span>. The proof of this equality is quite long and can be seen in [BN], Theorem 1.2.69.</p>
</div>
<div id="in-the-continuous-case-5" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case-5" class="anchor"></a>- in the continuous case</h4>
<p>The Laplace transform can be useful when computing the mean and variance of different types of distributions. Especially in phase-type theory it simplifies these types of computations.<br>
In general, the Laplace transform of a non-negative random variable <span class="math inline">\(\tau\)</span> is defined as <span class="math display">\[\begin{equation*}
L_{\tau}(s) = \mathbb{E}[e^{-s\tau}] = \int_{0}^{\infty} e^{-su} f_{\tau}(u) du,
\end{equation*}\]</span> where <span class="math inline">\(f_{\tau}(u)\)</span> is the density of the random variable <span class="math inline">\(\tau\)</span>. Furthermore, the <span class="math inline">\(n\)</span>’th derivative of the Laplace transform is given by <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial s^n} L_{\tau}(s) &amp;= \frac{\partial^n}{\partial s^n}  \int_{0}^{\infty} e^{-su} f_{\tau}(u) du\\
&amp;= \int_{0}^{\infty} \frac{\partial^n}{\partial s^n} e^{-su} f_{\tau}(u) du\\
&amp;= \int_{0}^{\infty} (-u)^n e^{-su} f_{\tau}(u) du,
\end{align*}\]</span> where the second equality is due to Leibniz integration rule. When evaluating this derivative at <span class="math inline">\(s=0\)</span>, we see that <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial s^n} L_{\tau}(0) =\int_{0}^{\infty} (-u)^n e^{-0 \cdot u} f_{\tau}(u) du =(-1)^n\int_{0}^{\infty} u^n f_{\tau}(u) du.
\end{align*}\]</span> We recognize this last integral as the definition of the <span class="math inline">\(n\)</span>’th moment of <span class="math inline">\(\tau\)</span>, i.e. <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial s^n} L_{\tau}(0) =(-1)^n\int_{0}^{\infty} u^n f_{\tau}(u) du = (-1)^n\mathbb{E}[\tau^n].
\end{align*}\]</span> Now we can apply this theory on continuous phase-type distributions.<br>
As <span class="math inline">\(f_{\tau}(u) = \pi e^{Tu} t\)</span> when <span class="math inline">\(\tau \sim \text{PH}(\pi, T)\)</span>, we have that <span class="math display">\[\begin{align*}
L_{\tau}(s) &amp;= \int_{0}^{\infty} e^{-su} \pi e^{Tu} t \, du\\
&amp;= \pi\int_{0}^{\infty}  e^{-su I} e^{Tu}  du \, t\\
&amp;= \pi\int_{0}^{\infty}  e^{-(sI-T)u} du \,  t\\
&amp;= \pi \lim_{r \rightarrow \infty} \Big[ -(sI-T)^{-1}e^{-(sI-T)u} \Big]_0^{r}   t\\
&amp;= \pi \lim_{r \rightarrow \infty} \Big( (sI-T)^{-1}e^{-(sI-T)r}+(sI-T)^{-1}e^{-(sI-T)\cdot 0} \Big)   t\\
&amp;= \pi (sI-T)^{-1}   t,
\end{align*}\]</span> where we have used that <span class="math inline">\(\lim_{r \rightarrow \infty} -(sI-T)^{-1}e^{-(sI-T)r} =0\)</span>, as the eigenvalues of <span class="math inline">\(-(sI-T)\)</span> are negative.<br>
Now that we have found the Laplace transform, we can compute the derivative <span class="math display">\[\begin{align*}
\frac{\partial}{\partial s} L_{\tau}(s) &amp;= \frac{\partial}{\partial s} \pi (sI-T)^{-1}t\\
&amp;= -\pi (sI-T)^{-2}t,\\
\end{align*}\]</span> the second derivative <span class="math display">\[\begin{align*}
\frac{\partial^2}{\partial s^2} L_{\tau}(s) &amp;= \frac{\partial^2}{\partial s^2} \pi (sI-T)^{-1}t\\
&amp;= 2\pi (sI-T)^{-3}t,\\
\end{align*}\]</span> or in general the <span class="math inline">\(n\)</span>’th derivative <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial s^n} L_{\tau}(s) &amp;= \frac{\partial^n}{\partial s^n} \pi (sI-T)^{-1}t\\
&amp;= (-1)^n n! \pi (sI-T)^{-n-1}t,\\
\end{align*}\]</span> where <span class="math inline">\(n \geq 1\)</span>.<br>
By evaluating the <span class="math inline">\(n\)</span>’th derivative of the Laplace transform at <span class="math inline">\(s=0\)</span>, we get that <span class="math display">\[\begin{align*}
\frac{\partial^n}{\partial s^n} L_{\tau}(0) &amp;=  (-1)^n n! \pi (0 \cdot I-T)^{-n-1}t\\
&amp;= (-1)^n n! \pi (-T)^{-n-1}t\\
&amp;= (-1)^n n! \pi (-T)^{-n-1}(-T)e\\
&amp;= (-1)^n n! \pi (-T)^{-n}e,
\end{align*}\]</span> where we have used that <span class="math inline">\(t=-Te\)</span>.<br>
By combining this equality with the fact that <span class="math inline">\(\frac{\partial^n}{\partial s^n} L_{\tau}(0) = (-1)^n\mathbb{E}[\tau^n]\)</span> in general, we have that <span class="math display">\[\begin{align*}
(-1)^n\mathbb{E}[\tau^n] = \frac{\partial^n}{\partial s^n} L_{\tau}(0) =(-1)^n n! \pi (-T)^{-n}e,
\end{align*}\]</span> which shows that the <span class="math inline">\(n\)</span>’th moment of <span class="math inline">\(\tau\)</span> is given as <span class="math display">\[\begin{align*}
\mathbb{E}[\tau^n] =  n! \pi (-T)^{-n}e.
\end{align*}\]</span></p>
</div>
<div id="example-13" class="section level4">
<h4 class="hasAnchor">
<a href="#example-13" class="anchor"></a>Example 13</h4>
<p>The computation of the (factorial) moments of a phase-type distribution can be performed by the aid of the function <code>moments</code>. This function needs a phase-type distributed object (either discrete or continuous) and computes the <span class="math inline">\(i\)</span>’th-order (factorial) moment or all moments up to the <span class="math inline">\(i\)</span>’th-order (factorial) moment.<br>
This function makes it easy to calculate the mean and variances of a given phase-type distribution (see also section <em>Mean and variance</em>).<br>
For <span class="math inline">\(n=4\)</span>, the waiting time to the most recent common ancestor <span class="math inline">\(\tau_{\text{MRCA}}\)</span> is continuous phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0)\)</span> and sub-intensity rate matrix <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
-6 &amp; 6 &amp; 0\\
0 &amp; -3 &amp; 3\\
0 &amp; 0 &amp; -1
\end{pmatrix}.
\end{equation*}\]</span> From the previous computations, we have that <span class="math display">\[\begin{equation*}
\mathbb{E}[\tau_{\text{MRCA}}] =  \pi (-T)^{-1}e
\end{equation*}\]</span> and that <span class="math display">\[\begin{equation*}
\mathbb{V}\text{ar}[\tau_{\text{MRCA}}] =  \mathbb{E}[\tau_{\text{MRCA}}^2]- \mathbb{E}[\tau_{\text{MRCA}}]^2 = 2 \pi (-T)^{-2}e - \big( \pi (-T)^{-1}e \big)^2.
\end{equation*}\]</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>initDist &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a>T_Mat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">0</span>,</span>
<span id="cb18-4"><a href="#cb18-4"></a>                  <span class="dv">0</span>,<span class="op">-</span><span class="dv">3</span>,<span class="dv">3</span>,</span>
<span id="cb18-5"><a href="#cb18-5"></a>                  <span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">## Defining an object of type "contphasetype"</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>TMRCA &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(initDist, T_Mat)</span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="co">## Computing all moments up to order 2</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>m &lt;-<span class="st"> </span><span class="kw"><a href="../reference/moments.html">moments</a></span>(TMRCA, <span class="dt">i=</span><span class="dv">2</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="co">## We get the desired numbers</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>m[<span class="dv">1</span>] </span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="co">#&gt;   1 </span></span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="co">#&gt; 1.5</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>m[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>m[<span class="dv">1</span>]<span class="op">^</span><span class="dv">2</span> </span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="co">#&gt;        2 </span></span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="co">#&gt; 1.138889</span></span>
<span id="cb18-18"><a href="#cb18-18"></a></span>
<span id="cb18-19"><a href="#cb18-19"></a><span class="kw"><a href="../reference/phmean.html">phmean</a></span>(TMRCA)</span>
<span id="cb18-20"><a href="#cb18-20"></a><span class="co">#&gt; [1] 1.5</span></span>
<span id="cb18-21"><a href="#cb18-21"></a><span class="kw"><a href="../reference/phmean.html">phvar</a></span>(TMRCA)</span>
<span id="cb18-22"><a href="#cb18-22"></a><span class="co">#&gt; [1] 1.138889</span></span></code></pre></div>
<p>For <span class="math inline">\(n=4\)</span> and <span class="math inline">\(\theta=2\)</span>, the number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> plus 1 is discrete phase-type distributed with initial distribution <span class="math inline">\(\pi = (1,0,0,0)\)</span> and sub-transition probability matrix <span class="math display">\[\begin{equation*}
T = \begin{pmatrix}
0.4 &amp; 0.3 &amp; 4/30 &amp; 2/30\\
0 &amp; 0.5 &amp; 2/9 &amp; 1/9\\
0 &amp; 0 &amp; 2/3 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 2/3
\end{pmatrix}.
\end{equation*}\]</span> Hence, it holds that <span class="math display">\[\begin{equation*}
\mathbb{E}[S_{\text{Total}}+1] = \pi (I-T)^{-1} e
\end{equation*}\]</span> and that <span class="math display">\[\begin{align*}
\mathbb{V}\text{ar}[S_{\text{Total}}] &amp;= \mathbb{E}[S_{\text{Total}}^2]- \mathbb{E}[S_{\text{Total}}]^2\\
&amp;= \mathbb{E}[S_{\text{Total}}^2]- \mathbb{E}[S_{\text{Total}}] +  \mathbb{E}[S_{\text{Total}}]- \mathbb{E}[S_{\text{Total}}]^2\\
&amp;= \mathbb{E}[S_{\text{Total}}^2- S_{\text{Total}}] +  \mathbb{E}[S_{\text{Total}}]- \mathbb{E}[S_{\text{Total}}]^2\\
&amp;= \mathbb{E}[S_{\text{Total}}(S_{\text{Total}}-1)] +  \mathbb{E}[S_{\text{Total}}]- \mathbb{E}[S_{\text{Total}}]^2\\
&amp;= 2\pi T(I-T)^{-2}e + \pi (I-T)^{-1} e - \big( \pi (I-T)^{-1} e\big)^2.
\end{align*}\]</span></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>initDist &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a>Pmat &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.4</span>, <span class="fl">0.3</span>, <span class="dv">4</span><span class="op">/</span><span class="dv">30</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">30</span>,</span>
<span id="cb19-4"><a href="#cb19-4"></a>                  <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">9</span>,</span>
<span id="cb19-5"><a href="#cb19-5"></a>                  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">0</span>,</span>
<span id="cb19-6"><a href="#cb19-6"></a>                  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>), <span class="dt">nrow =</span> <span class="dv">4</span>, <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="co">## Defining an object of type "discphasetype"</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>S_Total &lt;-<span class="st"> </span><span class="kw"><a href="../reference/discphasetype.html">discphasetype</a></span>(initDist, Pmat)</span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="co">## Computing all moments up to order 2</span></span>
<span id="cb19-10"><a href="#cb19-10"></a>m &lt;-<span class="st"> </span><span class="kw"><a href="../reference/moments.html">moments</a></span>(S_Total, <span class="dt">i=</span><span class="dv">2</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="co">## We get the desired numbers</span></span>
<span id="cb19-12"><a href="#cb19-12"></a>m[<span class="dv">1</span>]</span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="co">#&gt;        1 </span></span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="co">#&gt; 4.666667</span></span>
<span id="cb19-15"><a href="#cb19-15"></a>m[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span>m[<span class="dv">1</span>] <span class="op">-</span><span class="st"> </span>m[<span class="dv">1</span>]<span class="op">^</span><span class="dv">2</span> </span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co">#&gt;        2 </span></span>
<span id="cb19-17"><a href="#cb19-17"></a><span class="co">#&gt; 9.111111</span></span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="kw"><a href="../reference/phmean.html">phmean</a></span>(S_Total)</span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="co">#&gt; [1] 4.666667</span></span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="kw"><a href="../reference/phmean.html">phvar</a></span>(S_Total)</span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="co">#&gt; [1] 9.111111</span></span></code></pre></div>
<hr>
<p><strong>phsum</strong> </p>
<hr>
</div>
</div>
<div id="sums-of-independent-phase-type-distributions" class="section level3">
<h3 class="hasAnchor">
<a href="#sums-of-independent-phase-type-distributions" class="anchor"></a>Sums of independent phase-type distributions</h3>
<div id="in-the-discrete-case-6" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-discrete-case-6" class="anchor"></a>- in the discrete case</h4>
<p>Consider <span class="math inline">\(\tau_1\sim DPH_{p}(\alpha,S)\)</span> and <span class="math inline">\(\tau_2\sim DPH_{q}(\beta,T)\)</span> independent. Then by Theorem 1.2.65 in [BN]</p>
<p><span class="math display">\[\begin{equation*}
\tau_1+\tau_2\sim DPH_{p+q}\bigg(\begin{pmatrix}\alpha &amp; \boldsymbol{0}\end{pmatrix},\begin{pmatrix}S &amp; s\beta \\ \boldsymbol{0} &amp; T\end{pmatrix}\bigg),
\end{equation*}\]</span> where <span class="math inline">\(s=\boldsymbol{e}-S\boldsymbol{e}\)</span> is the vector of exit-probabilities from <span class="math inline">\(S\)</span>.<br></p>
<p>The proof of this is that we take the two underlying Markov Chains and knit them together to form a new Markov Chain that first has to behave as the Markov Chain corresponding to <span class="math inline">\(\tau_1\)</span> until it is absorbed and from then on behave as the Markov Chain corresponding to <span class="math inline">\(\tau_2\)</span>. The waiting time for absorption in this new Markov Chain then has the same distribution as <span class="math inline">\(\tau_1+\tau_2\)</span>.<br>
Formally the way we make this new Markov Chain is that the state space is <span class="math inline">\(\{1,\dotsc,p+q+1\}\)</span> and we make the states <span class="math inline">\(\{1,\dotsc,p\}\)</span> correspond to the <span class="math inline">\(p\)</span> transient states in the Markov Chain underlying <span class="math inline">\(\tau_1\)</span> and the states <span class="math inline">\(\{p+1,\dotsc,p+q\}\)</span> correspond to the <span class="math inline">\(q\)</span> transient states in the Markov Chain underlying <span class="math inline">\(\tau_2\)</span>.<br>
The initial distribution for the sum is <span class="math inline">\(\begin{pmatrix}\alpha &amp; \boldsymbol{0}\end{pmatrix}\)</span> because then we will initialize in one of the states <span class="math inline">\(\{1,\dotsc,p\}\)</span> and the probability is that of the transient states for <span class="math inline">\(\tau_1\)</span>.  The probabilities for transition among the states <span class="math inline">\(\{1,\dotsc,p\}\)</span> is given by <span class="math inline">\(S\)</span>. In the new Markov Chain we combine the absorption of the first Markov Chain with in the initialization of the second Markov Chain. This is why the upper right corner of the the new sub-transition matrix is given <span class="math inline">\(s\beta\)</span>. This matrix has dimension <span class="math inline">\(p\times q\)</span> and for <span class="math inline">\(i\in\{1,\dotsc,p\}\)</span> and <span class="math inline">\(j\in\{1,\dotsc,q\}\)</span> the <span class="math inline">\((i,j)\)</span>’th entry is <span class="math inline">\(s_i\beta_j\)</span>, which is the probability of exiting the first Markov Chain from state <span class="math inline">\(i\)</span> and entering the second Markov chain in state its <span class="math inline">\(j\)</span>’th state. The probabilities for transition among the states <span class="math inline">\(\{p+1,\dotsc,p+q\}\)</span> are the same as transition among the <span class="math inline">\(q\)</span> transient states underlying <span class="math inline">\(\tau_2\)</span>, and is given by <span class="math inline">\(T\)</span>.<br>
This theorem is implemented in the <code>phsum</code>-function. It takes two phase-type objects as input and if both of these are of the <code>discphasetype</code>-class, then it outputs an object of the <code>discphasetype</code>-class with parameters calculated from the parameters of the given objects in accordance with the above theorem.</p>
</div>
<div id="example-14" class="section level4">
<h4 class="hasAnchor">
<a href="#example-14" class="anchor"></a>Example 14</h4>
<p>Suppose that <span class="math display">\[\begin{equation*}
\tau_1\sim DPH_{2}(\begin{pmatrix}0.5 &amp; 0.5\end{pmatrix},\begin{pmatrix}0.4 &amp; 0.2 \\ 0.9 &amp; 0\end{pmatrix})
\end{equation*}\]</span> and <span class="math display">\[\begin{equation*}
\tau_2\sim DPH_{2}(\begin{pmatrix}0.75 &amp; 0.2\end{pmatrix},\begin{pmatrix}0.1 &amp; 0.7 \\ 0.2 &amp; 0.7\end{pmatrix})
\end{equation*}\]</span> then <span class="math display">\[\begin{equation*}
\begin{pmatrix}0.1 \\ 0.1\end{pmatrix}\begin{pmatrix}0.75 &amp; 0.2\end{pmatrix}=\begin{pmatrix}0.075 &amp; 0.02\\ 0.075 &amp; 0.02\end{pmatrix}
\end{equation*}\]</span> so <span class="math inline">\(\tau_1+\tau_2\)</span> follows a discrete phase-type distribution with initial distribution <span class="math display">\[\begin{equation*}
\begin{pmatrix} 0.5 &amp; 0.5 &amp; 0 &amp; 0\end{pmatrix}
\end{equation*}\]</span> and sub-transition probability matrix <span class="math display">\[\begin{equation*}
\begin{pmatrix}0.4 &amp; 0.2 &amp; 0.075 &amp; 0.02\\
               0.9 &amp; 0 &amp; 0.075 &amp; 0.02\\
               0 &amp; 0 &amp; 0.1 &amp; 0.7 \\
               0 &amp; 0 &amp; 0.2 &amp; 0.7\end{pmatrix}
\end{equation*}\]</span></p>
</div>
<div id="in-the-continuous-case-6" class="section level4">
<h4 class="hasAnchor">
<a href="#in-the-continuous-case-6" class="anchor"></a>- in the continuous case</h4>
<p>Consider <span class="math inline">\(X\sim PH_{p}(\alpha,S)\)</span> and <span class="math inline">\(Y\sim PH_{q}(\beta,T)\)</span> independent. Then by Theorem 3.1.26 in [BN] <span class="math display">\[\begin{equation*}
X+Y\sim PH_{p+q}\bigg(\begin{pmatrix}\alpha &amp; \boldsymbol{0}\end{pmatrix},\begin{pmatrix}S &amp; s\beta \\ \boldsymbol{0} &amp; T\end{pmatrix}\bigg),
\end{equation*}\]</span> where <span class="math inline">\(s=-S\boldsymbol{e}\)</span> is the vector of exit-rates from <span class="math inline">\(S\)</span>.<br>
Similarly to the discrete case the proof of this is constructing a Markov Jump Process behaves as the Markov Jump Process underlying <span class="math inline">\(X\)</span> until it is absorbed and from then on behaves as the Markov Jump Process underlying <span class="math inline">\(Y\)</span>.<br>
Similar consideration as in the discrete case show that one way of making such a Markov Jump Process is with initial distribution and sub-intensity matrix as stated in the theorem. This theorem is implemented in the <code>phsum</code>-function. It takes two phase-type objects as input and if both of these are of the <code>contphasetype</code>-class, then it outputs an object of the <code>contphasetype</code>-class with parameters calculated from the parameters of the given objects in accordance with the above theorem.</p>
</div>
<div id="example-15" class="section level4">
<h4 class="hasAnchor">
<a href="#example-15" class="anchor"></a>Example 15</h4>
<p>Suppose a random variable <span class="math inline">\(E\)</span> follows an exponential distribution with parameter <span class="math inline">\(\lambda&gt;0\)</span>. Then by comparing the distribution functions we see that that <span class="math inline">\(E\sim PH_{1}(1,-\lambda)\)</span>. It now follows that if <span class="math inline">\(E_1,\dotsc,E_n\)</span> are independent exponentially distributed random variables with respective parameters <span class="math inline">\(\lambda_1,\dotsc,\lambda_n\)</span> then</p>
<p><span class="math display">\[\begin{equation*}
\sum_{i=1}^{n}E_i\sim PH_{n}(\begin{pmatrix}1 &amp; 0 &amp; \cdots &amp; 0\end{pmatrix},\Lambda_n),
\end{equation*}\]</span> where the <span class="math inline">\((i,j)\)</span>’th entry of <span class="math inline">\(\Lambda_n\)</span> is given by <span class="math display">\[\begin{equation*}
(\Lambda_n)_{i,j}=
\begin{cases}   \lambda_i, &amp;\text{ if }j=i+1,\\
               -\lambda_i, &amp;\text{ if }j=i,\\
                 0, &amp; \text{ otherwise.}
\end{cases}
\end{equation*}\]</span></p>
<hr>
<p><strong>RewTransDistribution</strong> </p>
<hr>
</div>
</div>
<div id="transformation-via-rewards-1" class="section level3">
<h3 class="hasAnchor">
<a href="#transformation-via-rewards-1" class="anchor"></a>Transformation via rewards</h3>
<p>Starting from a continuous phase-type distributed random variable <span class="math inline">\(\tau\sim PH_p(\alpha,T)\)</span>, we can do what is called a reward-transformation of the underlying Markov Jump Process <span class="math inline">\(\{X_t\}_{t\geq0}\)</span>. Formally we let <span class="math inline">\(r=(r(1),\dotsc,r(p))\)</span> be a vector of non-negative numbers(the reward vector) and write <span class="math display">\[\begin{equation*}
Y=\int_{0}^{\tau}r(X_t)\text{d}t.
\end{equation*}\]</span> Mogens Bladt and Bo Friis Nielsen([BN] Theorem 3.1.33) prove that the random variable <span class="math inline">\(Y\)</span> follows a continuous phase-type distribution.<br><span class="math inline">\(Y\)</span> should be interpreted as <span class="math display">\[\begin{equation*}Y=\sum_{i=1}^{p}r(i)Z_i,
\end{equation*}\]</span> <span class="math inline">\(Z_i\)</span> is the total time spent in state <span class="math inline">\(i\)</span> prior to absorption. If <span class="math inline">\(r(i)&gt;0\)</span> for all <span class="math inline">\(i\)</span> then <span class="math display">\[\begin{equation*}Y\sim PH_p(\alpha,\Delta(r)^{-1}T).
\end{equation*}\]</span> Because the holding time in state <span class="math inline">\(i\)</span> is exponentially distributed with parameter <span class="math inline">\(-t_{i,i}\)</span>. Handling a case where <span class="math inline">\(r(i)=0\)</span> for some <span class="math inline">\(i\)</span> is a lot more tricky.<br>
Basically we want to find the rate matrix for the Markov Jump Process that arises when we take <span class="math inline">\(\{X_t\}_{t\geq0}\)</span> and delete any transitions into a state for which the reward is <span class="math inline">\(0\)</span>, and subsequently delete any possible self-transitions. Afterwards we transform this Markov Jump Process as before, because the remaining states <span class="math inline">\(i\)</span> all satisfy <span class="math inline">\(r(i)&gt;0\)</span>.<br>
Before the deletion the probability of <span class="math inline">\(\{X_t\}_{t\geq0}\)</span> transitioning from a one transient state <span class="math inline">\(i\)</span> to another transient state <span class="math inline">\(j\)</span> is <span class="math inline">\(-\frac{t_{i,j}}{t_{i,i}}\)</span>. Let’s say that <span class="math inline">\(r(i)&gt;0\)</span> and <span class="math inline">\(r(j)&gt;0\)</span>. After the “deletion” of the <span class="math inline">\(0\)</span>-reward states there are many ways of transitioning from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>. Leaving <span class="math inline">\(i\)</span>, <span class="math inline">\(\{X_t\}_{t\geq0}\)</span> could transition to a <span class="math inline">\(0\)</span>-reward transient state and from there make finitely many jumps among <span class="math inline">\(0\)</span>-reward transient states before jumping to <span class="math inline">\(j\)</span>, but in the “deletion” process this would only register as a jump from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.<br>
The transformation also impacts the initial distribution, because initializing in a <span class="math inline">\(0\)</span>-reward transient state will be ignored, but <span class="math inline">\(\{X_t\}_{t\geq0}\)</span> could be absorbed directly from a <span class="math inline">\(0\)</span>-reward state before visiting a state with a strictly positive reward. There the entries of the initial distribution for <span class="math inline">\(Y\)</span> do not necessarily add up to <span class="math inline">\(1\)</span>.</p>
<div id="the-function" class="section level4">
<h4 class="hasAnchor">
<a href="#the-function" class="anchor"></a>The function</h4>
<p>In the <code>PhaseTypeGenetics</code> we have implemented the function <code>RewTransDistribution</code>. It takes two parameters <code>object</code> and <code>rewards</code>. <code>object</code> is the <code>contphasetype</code> basis for the transformation (<span class="math inline">\(\tau\)</span> in the above), and <code>rewards</code> is the vector of rewards to transform <code>object</code> by(<span class="math inline">\(r\)</span> in the above.) The function returns a <code>contphasetype</code> object with the parameters obtained from Theorem 3.1.33 in [BN].</p>
</div>
<div id="example-16" class="section level4">
<h4 class="hasAnchor">
<a href="#example-16" class="anchor"></a>Example 16</h4>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a></span>
<span id="cb20-2"><a href="#cb20-2"></a>(x_<span class="dv">2</span> &lt;-<span class="st">  </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">2</span>,.<span class="dv">7</span>), </span>
<span id="cb20-3"><a href="#cb20-3"></a>                                <span class="dt">T_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">7</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">4</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)))</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co">#&gt; [1] 0.2 0.7</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co">#&gt; </span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">#&gt; $T_Mat</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="co">#&gt;      [,1] [,2]</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="co">#&gt; [1,]   -7    2</span></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co">#&gt; [2,]    3   -4</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="co">#&gt; </span></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="co">#&gt; [1] "contphasetype"</span></span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="kw"><a href="../reference/RewTransDistribution.html">RewTransDistribution</a></span>(x_<span class="dv">2</span>, <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="co">#&gt; [1] 0.2 0.7</span></span>
<span id="cb20-18"><a href="#cb20-18"></a><span class="co">#&gt; </span></span>
<span id="cb20-19"><a href="#cb20-19"></a><span class="co">#&gt; $T_Mat</span></span>
<span id="cb20-20"><a href="#cb20-20"></a><span class="co">#&gt;      [,1]      [,2]</span></span>
<span id="cb20-21"><a href="#cb20-21"></a><span class="co">#&gt; [1,] -3.5  1.000000</span></span>
<span id="cb20-22"><a href="#cb20-22"></a><span class="co">#&gt; [2,]  1.0 -1.333333</span></span>
<span id="cb20-23"><a href="#cb20-23"></a><span class="co">#&gt; </span></span>
<span id="cb20-24"><a href="#cb20-24"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb20-25"><a href="#cb20-25"></a><span class="co">#&gt; [1] "contphasetype"</span></span>
<span id="cb20-26"><a href="#cb20-26"></a></span>
<span id="cb20-27"><a href="#cb20-27"></a>(x_<span class="dv">1</span> &lt;-<span class="st">  </span><span class="kw"><a href="../reference/discphasetype.html">contphasetype</a></span>(<span class="dt">initDist =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(.<span class="dv">5</span>,.<span class="dv">2</span>,.<span class="dv">3</span>,<span class="dv">0</span>),</span>
<span id="cb20-28"><a href="#cb20-28"></a>                                 <span class="dt">T_Mat =</span> <span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">4</span>), <span class="dt">nrow =</span> <span class="dv">4</span>)))</span>
<span id="cb20-29"><a href="#cb20-29"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb20-30"><a href="#cb20-30"></a><span class="co">#&gt; [1] 0.5 0.2 0.3 0.0</span></span>
<span id="cb20-31"><a href="#cb20-31"></a><span class="co">#&gt; </span></span>
<span id="cb20-32"><a href="#cb20-32"></a><span class="co">#&gt; $T_Mat</span></span>
<span id="cb20-33"><a href="#cb20-33"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb20-34"><a href="#cb20-34"></a><span class="co">#&gt; [1,]   -6    2    2    0</span></span>
<span id="cb20-35"><a href="#cb20-35"></a><span class="co">#&gt; [2,]    1   -8    3    3</span></span>
<span id="cb20-36"><a href="#cb20-36"></a><span class="co">#&gt; [3,]    1    0   -5    2</span></span>
<span id="cb20-37"><a href="#cb20-37"></a><span class="co">#&gt; [4,]    0    0    0   -4</span></span>
<span id="cb20-38"><a href="#cb20-38"></a><span class="co">#&gt; </span></span>
<span id="cb20-39"><a href="#cb20-39"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb20-40"><a href="#cb20-40"></a><span class="co">#&gt; [1] "contphasetype"</span></span>
<span id="cb20-41"><a href="#cb20-41"></a></span>
<span id="cb20-42"><a href="#cb20-42"></a><span class="kw"><a href="../reference/RewTransDistribution.html">RewTransDistribution</a></span>(x_<span class="dv">1</span>, <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>))</span>
<span id="cb20-43"><a href="#cb20-43"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb20-44"><a href="#cb20-44"></a><span class="co">#&gt;           [,1]      [,2]</span></span>
<span id="cb20-45"><a href="#cb20-45"></a><span class="co">#&gt; [1,] 0.3666667 0.4666667</span></span>
<span id="cb20-46"><a href="#cb20-46"></a><span class="co">#&gt; </span></span>
<span id="cb20-47"><a href="#cb20-47"></a><span class="co">#&gt; $T_Mat</span></span>
<span id="cb20-48"><a href="#cb20-48"></a><span class="co">#&gt;            [,1]      [,2]</span></span>
<span id="cb20-49"><a href="#cb20-49"></a><span class="co">#&gt; [1,] -4.0000000  1.666667</span></span>
<span id="cb20-50"><a href="#cb20-50"></a><span class="co">#&gt; [2,]  0.3333333 -5.000000</span></span>
<span id="cb20-51"><a href="#cb20-51"></a><span class="co">#&gt; </span></span>
<span id="cb20-52"><a href="#cb20-52"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb20-53"><a href="#cb20-53"></a><span class="co">#&gt; [1] "contphasetype"</span></span></code></pre></div>
<hr>
<p><strong>SiteFrequencies</strong> </p>
<hr>
</div>
</div>
<div id="the-site-frequency-spectrum" class="section level3">
<h3 class="hasAnchor">
<a href="#the-site-frequency-spectrum" class="anchor"></a>The site frequency spectrum</h3>
<p>The function <code>SiteFrequencies</code> is another example of a function that is intended for the use in population genetics. It can be used to find the discrete phase-type representation (i.e. the initial distribution and sub-transition probability matrix) of the site frequencies <span class="math inline">\(\xi_i + 1\)</span>, the number of segregating sites <span class="math inline">\(S_{\text{Total}} +1\)</span> and the tail statistics <span class="math inline">\(S_{i+} + 1\)</span> for all <span class="math inline">\(i \in \{1,...,n-1\}\)</span>, where <span class="math inline">\(n\)</span> is the desired sample size.<br>
The reason for adding one to all of the three waiting times is that the support for discrete phase-type distributions is on the natural numbers excluding zero, which implies that immediate absorption would not be possible. By adding one to the waiting times, the waiting time itself can attain the value 0.<br>
A more detailed explanation of what the function computes is given in the following.<br>
For <code>nSegSites = TRUE</code>, the function computes the discrete phase-type representation of the number of segregating sites <span class="math inline">\(S_{\text{Total}} +1 = \xi_1 + \cdots + \xi_{n-1}+1\)</span> for a given sample size <span class="math inline">\(n\)</span> and a non-negative mutation rate <span class="math inline">\(\lambda\)</span>. In order to obtain the representation, the function uses the the block counting process together with the reward transformation and the discretization. All of these three topics are discussed in other sections. In short, we obtain the distribution for the waiting time to the most recent common ancestor <span class="math inline">\(\tau_{\text{MRCA}}\)</span> from the block counting process. Then we use the reward transformation to find the distribution of the total branch length <span class="math inline">\(\tau_{\text{Total}}\)</span>. Afterwards, the distribution of the total number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> is computed by the aid of the discretization with <span class="math inline">\(\lambda\)</span> being equal to the mutation rate.<br>
For <code>tailStat = TRUE</code>, the function finds the discrete phase-type representations of the tail statistic <span class="math inline">\(S_{i+} +1= \xi_i + \cdots + \xi_{n-1} +1\)</span> for a given sample size <span class="math inline">\(n\)</span>, a value of <span class="math inline">\(1 \leq i \leq n-1\)</span> and a non-negative mutation rate <span class="math inline">\(\lambda\)</span>. Note that <span class="math inline">\(i\)</span> determines the first term of the tail statistic. As for the number of segregating sites, the function uses the the block counting process together with the reward transformation and the discretization in order to obtain the representation; The distribution for the waiting time to the most recent common ancestor <span class="math inline">\(\tau_{\text{MRCA}}\)</span> is obtained from the block counting process. Then the reward transformation is used to find the distribution of the total length of all branches having <span class="math inline">\(i\)</span> or more descendants, <span class="math inline">\(\tau_{i+}\)</span>. Afterwards, the distribution of the tail statistic <span class="math inline">\(S_{i+}\)</span> is computed by the aid of the discretization with <span class="math inline">\(\lambda\)</span> being equal to the mutation rate.<br>
Finally, if <code>nSegSites = FALSE</code> and <code>tailStat= FALSE</code>, the function returns the discrete phase-type representation of the <span class="math inline">\(i\)</span>’th site frequency <span class="math inline">\(\xi_i\)</span> for a given sample size <span class="math inline">\(n\)</span>, a value of <span class="math inline">\(1 \leq i \leq n-1\)</span> and a non-negative mutation rate <span class="math inline">\(\lambda\)</span>. Here <span class="math inline">\(i\)</span> determines the number of the site frequency that should be considered. As for the number of segregating sites and the tail statistic <span class="math inline">\(S_{i+}\)</span>, the function uses the the block counting process together with the reward transformation and the discretization in order to obtain the representation; The distribution for the waiting time to the most recent common ancestor <span class="math inline">\(\tau_{\text{MRCA}}\)</span> is obtained from the block counting process. Then the reward transformation is used to find the distribution of the total length of all branches having <span class="math inline">\(i\)</span> descendants, <span class="math inline">\(\tau_{i}\)</span>. Finally, the distribution of the site frequency <span class="math inline">\(\xi_i\)</span> is computed by the aid of the discretization with <span class="math inline">\(\lambda\)</span> being equal to the mutation rate.<br><br>
Note that the package does also include the function <code>dSegregatingSites</code>, which computes the density of the total number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> for a given sample size <span class="math inline">\(n\)</span> and a mutation parameter <span class="math inline">\(\theta\)</span>, directly. Note also that <code>SiteFrequencies</code> uses the package <code>partitions</code>. Make sure to install this package to be able to use the function.</p>
<div id="example-17" class="section level4">
<h4 class="hasAnchor">
<a href="#example-17" class="anchor"></a>Example 17</h4>
<p>We can find the discrete phase-type representation of the site frequency <span class="math inline">\(\xi_2\)</span> for a sample of size <span class="math inline">\(n=4\)</span> and a mutation rate <span class="math inline">\(\lambda = 1\)</span>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw"><a href="../reference/SiteFrequencies.html">SiteFrequencies</a></span>(<span class="dt">n=</span><span class="dv">4</span>, <span class="dt">lambda=</span><span class="dv">1</span>, <span class="dt">i=</span><span class="dv">2</span>)</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co">#&gt;      [,1] [,2]</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co">#&gt; [1,]    1    0</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="co">#&gt; </span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="co">#&gt;      [,1]      [,2]</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="co">#&gt; [1,] 0.25 0.1666667</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="co">#&gt; [2,] 0.00 0.6666667</span></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="co">#&gt; </span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="co">#&gt; [1] "discphasetype"</span></span></code></pre></div>
<p>We can also compute the phase-type representation of the number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span> for a sample of size <span class="math inline">\(n=4\)</span> and the same mutation rate <span class="math inline">\(\lambda = 1\)</span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw"><a href="../reference/SiteFrequencies.html">SiteFrequencies</a></span>(<span class="dt">n=</span><span class="dv">4</span>, <span class="dt">lambda=</span><span class="dv">1</span>, <span class="dt">nSegSites=</span><span class="ot">TRUE</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="co">#&gt; [1] 1 0 0 0</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="co">#&gt; </span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="co">#&gt;      [,1] [,2]      [,3]       [,4]</span></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="co">#&gt; [1,]  0.4  0.3 0.1333333 0.06666667</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="co">#&gt; [2,]  0.0  0.5 0.2222222 0.11111111</span></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="co">#&gt; [3,]  0.0  0.0 0.6666667 0.00000000</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="co">#&gt; [4,]  0.0  0.0 0.0000000 0.66666667</span></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="co">#&gt; </span></span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="co">#&gt; [1] "discphasetype"</span></span></code></pre></div>
<p>Finally, we find the phase-type representation of the tail statistic <span class="math inline">\(S_{2+}\)</span> for the same sample size <span class="math inline">\(n=4\)</span> and the same mutation rate <span class="math inline">\(\lambda = 1\)</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw"><a href="../reference/SiteFrequencies.html">SiteFrequencies</a></span>(<span class="dt">n=</span><span class="dv">4</span>, <span class="dt">lambda=</span><span class="dv">1</span>, <span class="dt">i=</span><span class="dv">2</span>, <span class="dt">tailStat=</span><span class="ot">TRUE</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="co">#&gt; $initDist</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co">#&gt; [1,]    1    0    0</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="co">#&gt; </span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="co">#&gt; $P_Mat</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co">#&gt;      [,1] [,2]      [,3]</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="co">#&gt; [1,] 0.25 0.25 0.1666667</span></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="co">#&gt; [2,] 0.00 0.50 0.0000000</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="co">#&gt; [3,] 0.00 0.00 0.6666667</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="co">#&gt; </span></span>
<span id="cb23-12"><a href="#cb23-12"></a><span class="co">#&gt; attr(,"class")</span></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="co">#&gt; [1] "discphasetype"</span></span></code></pre></div>
<hr>
<p><strong>summary</strong> </p>
<hr>
</div>
</div>
<div id="summaries" class="section level3">
<h3 class="hasAnchor">
<a href="#summaries" class="anchor"></a>Summaries</h3>
<p>This package also provides a method to summaries objects of type <code>discphasetype</code> and <code>contphasetype</code>. The method is called <code>summary</code>, consistent with R language. It prints the type of the phase-type distribution (discrete/continuous), the initial distribution and the sub-intensity rate matrix or sub-transition probability matrix, respectively. In addition, it prints the defect size, if present.</p>
<div id="example-18" class="section level4">
<h4 class="hasAnchor">
<a href="#example-18" class="anchor"></a>Example 18</h4>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw"><a href="https://rdrr.io/r/base/summary.html">summary</a></span>(T_MRCA<span class="op">$</span>n10)</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="co">#&gt; A continuous phase-type distribution with initial probability vector </span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">#&gt; [1] 1 0 0 0 0 0 0 0 0</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co">#&gt; and subintensity matrix </span></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="co">#&gt;       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="co">#&gt;  [1,]  -45   45    0    0    0    0    0    0    0</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="co">#&gt;  [2,]    0  -36   36    0    0    0    0    0    0</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="co">#&gt;  [3,]    0    0  -28   28    0    0    0    0    0</span></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="co">#&gt;  [4,]    0    0    0  -21   21    0    0    0    0</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="co">#&gt;  [5,]    0    0    0    0  -15   15    0    0    0</span></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="co">#&gt;  [6,]    0    0    0    0    0  -10   10    0    0</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="co">#&gt;  [7,]    0    0    0    0    0    0   -6    6    0</span></span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="co">#&gt;  [8,]    0    0    0    0    0    0    0   -3    3</span></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="co">#&gt;  [9,]    0    0    0    0    0    0    0    0   -1</span></span></code></pre></div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction-to-phasetypegenetics">Introduction to PhaseTypeGenetics</a></li>
      <li>
<a href="#defining-phase-type-distributions">Defining phase-type distributions</a><ul class="nav nav-pills nav-stacked">
<li><a href="#the-discrete-phase-type-distribution">The discrete phase-type distribution</a></li>
      <li><a href="#the-continuous-phase-type-distribution">The continuous phase-type distribution</a></li>
      </ul>
</li>
      <li>
<a href="#applications-in-population-genetics">Applications in Population Genetics</a><ul class="nav nav-pills nav-stacked">
<li><a href="#the-wright-fisher-model">The Wright-Fisher model</a></li>
      <li><a href="#the-phase-type-distribution">The phase-type distribution</a></li>
      <li><a href="#transformation-via-rewards">Transformation via rewards</a></li>
      <li><a href="#the-total-branch-length">The total branch length</a></li>
      <li><a href="#the-site-frequencies">The site frequencies</a></li>
      </ul>
</li>
      <li>
<a href="#the-functions">The functions</a><ul class="nav nav-pills nav-stacked">
<li><a href="#the-block-counting-process">The block counting process</a></li>
      <li><a href="#objects-of-type-discphasetype-and-contphasetype">Objects of type <code>discphasetype</code> and <code>contphasetype</code></a></li>
      <li><a href="#discretization-of-continuous-phase-type-distributions">Discretization of continuous phase-type distributions</a></li>
      <li><a href="#the-density">The density</a></li>
      <li><a href="#the-distribution-function">The distribution function</a></li>
      <li><a href="#the-quantile-function">The quantile function</a></li>
      <li><a href="#simulations">Simulations</a></li>
      <li><a href="#the-number-of-segregating-sites-s_texttotal">The number of segregating sites <span class="math inline">\(S_{\text{Total}}\)</span></a></li>
      <li><a href="#extrema-of-two-independent-phase-type-distributions">Extrema of two independent phase-type distributions</a></li>
      <li><a href="#mean-and-variance">Mean and variance</a></li>
      <li><a href="#moments-and-factorial-moments">Moments and factorial moments</a></li>
      <li><a href="#sums-of-independent-phase-type-distributions">Sums of independent phase-type distributions</a></li>
      <li><a href="#transformation-via-rewards-1">Transformation via rewards</a></li>
      <li><a href="#the-site-frequency-spectrum">The site frequency spectrum</a></li>
      <li><a href="#summaries">Summaries</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Peter Krarup, Jette Steinbach.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
